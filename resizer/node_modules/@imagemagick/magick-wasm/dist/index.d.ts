// Generated by dts-bundle-generator v9.5.1

export type ByteArray = Int8Array | Uint8Array | Uint8ClampedArray;
export interface IConfigurationFile {
	readonly fileName: string;
	data: string;
}
export interface IConfigurationFiles {
	all(): Generator<IConfigurationFile>;
	readonly log: IConfigurationFile;
	readonly policy: IConfigurationFile;
}
export declare class ConfigurationFiles implements IConfigurationFiles {
	private constructor();
	static default: IConfigurationFiles;
	all(): Generator<IConfigurationFile>;
	readonly log: IConfigurationFile;
	readonly policy: IConfigurationFile;
}
export declare const MagickFormat: {
	readonly Unknown: "UNKNOWN";
	readonly ThreeFr: "3FR";
	readonly ThreeG2: "3G2";
	readonly ThreeGp: "3GP";
	readonly A: "A";
	readonly Aai: "AAI";
	readonly Ai: "AI";
	readonly APng: "APNG";
	readonly Art: "ART";
	readonly Arw: "ARW";
	readonly Ashlar: "ASHLAR";
	readonly Avci: "AVCI";
	readonly Avi: "AVI";
	readonly Avif: "AVIF";
	readonly Avs: "AVS";
	readonly B: "B";
	readonly Bayer: "BAYER";
	readonly Bayera: "BAYERA";
	readonly Bgr: "BGR";
	readonly Bgra: "BGRA";
	readonly Bgro: "BGRO";
	readonly Bmp: "BMP";
	readonly Bmp2: "BMP2";
	readonly Bmp3: "BMP3";
	readonly Brf: "BRF";
	readonly C: "C";
	readonly Cal: "CAL";
	readonly Cals: "CALS";
	readonly Canvas: "CANVAS";
	readonly Caption: "CAPTION";
	readonly Cin: "CIN";
	readonly Cip: "CIP";
	readonly Clip: "CLIP";
	readonly Cmyk: "CMYK";
	readonly Cmyka: "CMYKA";
	readonly Cr2: "CR2";
	readonly Cr3: "CR3";
	readonly Crw: "CRW";
	readonly Cube: "CUBE";
	readonly Cur: "CUR";
	readonly Cut: "CUT";
	readonly Data: "DATA";
	readonly Dcm: "DCM";
	readonly Dcr: "DCR";
	readonly Dcraw: "DCRAW";
	readonly Dcx: "DCX";
	readonly Dds: "DDS";
	readonly Dfont: "DFONT";
	readonly Dng: "DNG";
	readonly Dpx: "DPX";
	readonly Dxt1: "DXT1";
	readonly Dxt5: "DXT5";
	readonly Epdf: "EPDF";
	readonly Epi: "EPI";
	readonly Eps: "EPS";
	readonly Eps2: "EPS2";
	readonly Eps3: "EPS3";
	readonly Epsf: "EPSF";
	readonly Epsi: "EPSI";
	readonly Ept: "EPT";
	readonly Ept2: "EPT2";
	readonly Ept3: "EPT3";
	readonly Erf: "ERF";
	readonly Exr: "EXR";
	readonly Farbfeld: "FARBFELD";
	readonly Fax: "FAX";
	readonly Ff: "FF";
	readonly Fff: "FFF";
	readonly File: "FILE";
	readonly Fits: "FITS";
	readonly Fl32: "FL32";
	readonly Flv: "FLV";
	readonly Fractal: "FRACTAL";
	readonly Ftp: "FTP";
	readonly Fts: "FTS";
	readonly Ftxt: "FTXT";
	readonly G: "G";
	readonly G3: "G3";
	readonly G4: "G4";
	readonly Gif: "GIF";
	readonly Gif87: "GIF87";
	readonly Gradient: "GRADIENT";
	readonly Gray: "GRAY";
	readonly Graya: "GRAYA";
	readonly Group4: "GROUP4";
	readonly Hald: "HALD";
	readonly Hdr: "HDR";
	readonly Heic: "HEIC";
	readonly Heif: "HEIF";
	readonly Histogram: "HISTOGRAM";
	readonly Hrz: "HRZ";
	readonly Htm: "HTM";
	readonly Html: "HTML";
	readonly Http: "HTTP";
	readonly Https: "HTTPS";
	readonly Icb: "ICB";
	readonly Ico: "ICO";
	readonly Icon: "ICON";
	readonly Iiq: "IIQ";
	readonly Info: "INFO";
	readonly Inline: "INLINE";
	readonly Ipl: "IPL";
	readonly Isobrl: "ISOBRL";
	readonly Isobrl6: "ISOBRL6";
	readonly J2c: "J2C";
	readonly J2k: "J2K";
	readonly Jng: "JNG";
	readonly Jnx: "JNX";
	readonly Jp2: "JP2";
	readonly Jpc: "JPC";
	readonly Jpe: "JPE";
	readonly Jpeg: "JPEG";
	readonly Jpg: "JPG";
	readonly Jpm: "JPM";
	readonly Jps: "JPS";
	readonly Jpt: "JPT";
	readonly Json: "JSON";
	readonly Jxl: "JXL";
	readonly K: "K";
	readonly K25: "K25";
	readonly Kdc: "KDC";
	readonly Label: "LABEL";
	readonly M: "M";
	readonly M2v: "M2V";
	readonly M4v: "M4V";
	readonly Mac: "MAC";
	readonly Map: "MAP";
	readonly Mask: "MASK";
	readonly Mat: "MAT";
	readonly Matte: "MATTE";
	readonly Mdc: "MDC";
	readonly Mef: "MEF";
	readonly Miff: "MIFF";
	readonly Mkv: "MKV";
	readonly Mng: "MNG";
	readonly Mono: "MONO";
	readonly Mov: "MOV";
	readonly Mos: "MOS";
	readonly Mp4: "MP4";
	readonly Mpc: "MPC";
	readonly Mpeg: "MPEG";
	readonly Mpg: "MPG";
	readonly Mpo: "MPO";
	readonly Mrw: "MRW";
	readonly Msl: "MSL";
	readonly Msvg: "MSVG";
	readonly Mtv: "MTV";
	readonly Mvg: "MVG";
	readonly Nef: "NEF";
	readonly Nrw: "NRW";
	readonly Null: "NULL";
	readonly O: "O";
	readonly Ora: "ORA";
	readonly Orf: "ORF";
	readonly Otb: "OTB";
	readonly Otf: "OTF";
	readonly Pal: "PAL";
	readonly Palm: "PALM";
	readonly Pam: "PAM";
	readonly Pango: "PANGO";
	readonly Pattern: "PATTERN";
	readonly Pbm: "PBM";
	readonly Pcd: "PCD";
	readonly Pcds: "PCDS";
	readonly Pcl: "PCL";
	readonly Pct: "PCT";
	readonly Pcx: "PCX";
	readonly Pdb: "PDB";
	readonly Pdf: "PDF";
	readonly Pdfa: "PDFA";
	readonly Pef: "PEF";
	readonly Pes: "PES";
	readonly Pfa: "PFA";
	readonly Pfb: "PFB";
	readonly Pfm: "PFM";
	readonly Pgm: "PGM";
	readonly Pgx: "PGX";
	readonly Phm: "PHM";
	readonly Picon: "PICON";
	readonly Pict: "PICT";
	readonly Pix: "PIX";
	readonly Pjpeg: "PJPEG";
	readonly Plasma: "PLASMA";
	readonly Png: "PNG";
	readonly Png00: "PNG00";
	readonly Png24: "PNG24";
	readonly Png32: "PNG32";
	readonly Png48: "PNG48";
	readonly Png64: "PNG64";
	readonly Png8: "PNG8";
	readonly Pnm: "PNM";
	readonly Pocketmod: "POCKETMOD";
	readonly Ppm: "PPM";
	readonly Ps: "PS";
	readonly Ps2: "PS2";
	readonly Ps3: "PS3";
	readonly Psb: "PSB";
	readonly Psd: "PSD";
	readonly Ptif: "PTIF";
	readonly Pwp: "PWP";
	readonly Qoi: "QOI";
	readonly R: "R";
	readonly RadialGradient: "RADIAL-GRADIENT";
	readonly Raf: "RAF";
	readonly Ras: "RAS";
	readonly Raw: "RAW";
	readonly Rgb: "RGB";
	readonly Rgb565: "RGB565";
	readonly Rgba: "RGBA";
	readonly Rgbo: "RGBO";
	readonly Rgf: "RGF";
	readonly Rla: "RLA";
	readonly Rle: "RLE";
	readonly Rmf: "RMF";
	readonly Rw2: "RW2";
	readonly Rwl: "RWL";
	readonly Scr: "SCR";
	readonly Screenshot: "SCREENSHOT";
	readonly Sct: "SCT";
	readonly Sfw: "SFW";
	readonly Sgi: "SGI";
	readonly Shtml: "SHTML";
	readonly Six: "SIX";
	readonly Sixel: "SIXEL";
	readonly SparseColor: "SPARSE-COLOR";
	readonly Sr2: "SR2";
	readonly Srf: "SRF";
	readonly Srw: "SRW";
	readonly Stegano: "STEGANO";
	readonly Sti: "STI";
	readonly StrImg: "STRIMG";
	readonly Sun: "SUN";
	readonly Svg: "SVG";
	readonly Svgz: "SVGZ";
	readonly Text: "TEXT";
	readonly Tga: "TGA";
	readonly Thumbnail: "THUMBNAIL";
	readonly Tif: "TIF";
	readonly Tiff: "TIFF";
	readonly Tiff64: "TIFF64";
	readonly Tile: "TILE";
	readonly Tim: "TIM";
	readonly Tm2: "TM2";
	readonly Ttc: "TTC";
	readonly Ttf: "TTF";
	readonly Txt: "TXT";
	readonly Ubrl: "UBRL";
	readonly Ubrl6: "UBRL6";
	readonly Uil: "UIL";
	readonly Uyvy: "UYVY";
	readonly Vda: "VDA";
	readonly Vicar: "VICAR";
	readonly Vid: "VID";
	readonly Viff: "VIFF";
	readonly Vips: "VIPS";
	readonly Vst: "VST";
	readonly WebM: "WEBM";
	readonly WebP: "WEBP";
	readonly Wbmp: "WBMP";
	readonly Wmv: "WMV";
	readonly Wpg: "WPG";
	readonly X3f: "X3F";
	readonly Xbm: "XBM";
	readonly Xc: "XC";
	readonly Xcf: "XCF";
	readonly Xpm: "XPM";
	readonly Xps: "XPS";
	readonly Xv: "XV";
	readonly Y: "Y";
	readonly Yaml: "YAML";
	readonly Ycbcr: "YCBCR";
	readonly Ycbcra: "YCBCRA";
	readonly Yuv: "YUV";
};
export type MagickFormat = typeof MagickFormat[keyof typeof MagickFormat];
export interface IDefine {
	readonly format: MagickFormat;
	readonly name: string;
	readonly value: string;
}
export interface IDefines {
	getDefines(): IDefine[];
}
export declare class MagickDefine implements IDefine {
	constructor(format: MagickFormat, name: string, value: string);
	readonly format: MagickFormat;
	readonly name: string;
	readonly value: string;
}
export declare abstract class DefinesCreator implements IDefines {
	protected format: MagickFormat;
	constructor(format: MagickFormat);
	abstract getDefines(): IDefine[];
	createDefine(name: string, value: boolean): MagickDefine;
	createDefine(name: string, value: number): MagickDefine;
	createDefine(name: string, value: string): MagickDefine;
	protected hasValue(value: unknown): boolean;
}
export interface IDisposable {
	dispose(): void;
}
export declare const Gravity: {
	readonly Undefined: 0;
	readonly Forget: 0;
	readonly Northwest: 1;
	readonly North: 2;
	readonly Northeast: 3;
	readonly West: 4;
	readonly Center: 5;
	readonly East: 6;
	readonly Southwest: 7;
	readonly South: 8;
	readonly Southeast: 9;
};
export type Gravity = typeof Gravity[keyof typeof Gravity];
export interface IMagickColor {
	r: number;
	g: number;
	b: number;
	a: number;
	k: number;
	isCmyk: boolean;
	toShortString(): string;
	toString(): string;
}
export declare class MagickColor implements IMagickColor {
	constructor(color?: string);
	constructor(r: number, g: number, b: number);
	constructor(r: number, g: number, b: number, a: number);
	constructor(c: number, m: number, y: number, k: number, a: number);
	r: number;
	g: number;
	b: number;
	a: number;
	k: number;
	isCmyk: boolean;
	toShortString(): string;
	toString(): string;
	private initialize;
	private toHex;
}
export declare abstract class NativeInstance {
	private readonly disposeMethod;
	private instance;
	protected onDispose?(): void;
	dispose(): void;
	private disposeInstance;
}
export declare const PaintMethod: {
	readonly Undefined: 0;
	readonly Point: 1;
	readonly Replace: 2;
	readonly Floodfill: 3;
	readonly FillToBorder: 4;
	readonly Reset: 5;
};
export type PaintMethod = typeof PaintMethod[keyof typeof PaintMethod];
export declare const TextAlignment: {
	readonly Undefined: 0;
	readonly Left: 1;
	readonly Center: 2;
	readonly Right: 3;
};
export type TextAlignment = typeof TextAlignment[keyof typeof TextAlignment];
export declare const TextDecoration: {
	readonly Undefined: 0;
	readonly None: 1;
	readonly Underline: 2;
	readonly Overline: 3;
	readonly LineThrough: 4;
};
export type TextDecoration = typeof TextDecoration[keyof typeof TextDecoration];
export interface IDrawingWand extends IDisposable {
	color(x: number, y: number, paintMethod: number): void;
	draw(drawables: IDrawable[]): void;
	fillColor(value: IMagickColor): void;
	fillOpacity(value: number): void;
	font(family: string): void;
	fontPointSize(value: number): void;
	gravity(value: Gravity): void;
	line(startX: number, startY: number, endX: number, endY: number): void;
	point(x: number, y: number): void;
	rectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number): void;
	roundRectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number, cornerWidth: number, cornerHeight: number): void;
	strokeColor(value: IMagickColor): void;
	strokeWidth(value: number): void;
	text(x: number, y: number, value: string): void;
	textAlignment(value: TextAlignment): void;
	textAntialias(value: boolean): void;
	textDecoration(value: TextDecoration): void;
	textInterlineSpacing(value: number): void;
	textInterwordspacing(value: number): void;
	textKerning(value: number): void;
	textUnderColor(value: IMagickColor): void;
}
export declare class DrawingWand extends NativeInstance implements IDrawingWand {
	private constructor();
	color(x: number, y: number, paintMethod: PaintMethod): void;
	draw(drawables: IDrawable[]): void;
	fillColor(value: IMagickColor): void;
	fillOpacity(value: number): void;
	font(fileName: string): void;
	fontPointSize(value: number): void;
	gravity(value: Gravity): void;
	line(startX: number, startY: number, endX: number, endY: number): void;
	point(x: number, y: number): void;
	rectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number): void;
	roundRectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number, cornerWidth: number, cornerHeight: number): void;
	strokeColor(value: IMagickColor): void;
	strokeWidth(value: number): void;
	text(x: number, y: number, value: string): void;
	textAlignment(value: TextAlignment): void;
	textAntialias(value: boolean): void;
	textDecoration(value: TextDecoration): void;
	textInterlineSpacing(value: number): void;
	textInterwordspacing(value: number): void;
	textKerning(value: number): void;
	textUnderColor(value: IMagickColor): void;
}
export interface IDrawable {
	draw(wand: IDrawingWand): void;
}
export declare class DrawableColor implements IDrawable {
	private readonly _x;
	private readonly _y;
	private readonly _paintMethod;
	constructor(x: number, y: number, paintMethod: PaintMethod);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableFillColor implements IDrawable {
	private readonly _color;
	constructor(color: IMagickColor);
	draw(wand: IDrawingWand): void;
}
export declare class Percentage {
	private _value;
	constructor(value: number);
	multiply(value: number): number;
	toDouble(): number;
	toString(): string;
}
export declare class DrawableFillOpacity implements IDrawable {
	private readonly _opacity;
	constructor(opacity: Percentage);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableFontPointSize implements IDrawable {
	private readonly _pointSize;
	constructor(pointSize: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableFont implements IDrawable {
	private readonly _font;
	constructor(font: string);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableGravity implements IDrawable {
	private readonly _gravity;
	constructor(gravity: Gravity);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableLine implements IDrawable {
	private readonly _startX;
	private readonly _startY;
	private readonly _endX;
	private readonly _endY;
	constructor(startX: number, startY: number, endX: number, endY: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawablePoint implements IDrawable {
	private readonly _x;
	private readonly _y;
	constructor(x: number, y: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableRectangle implements IDrawable {
	private readonly _upperLeftX;
	private readonly _upperLeftY;
	private readonly _lowerRightX;
	private readonly _lowerRightY;
	constructor(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableRoundRectangle implements IDrawable {
	private readonly _upperLeftX;
	private readonly _upperLeftY;
	private readonly _lowerRightX;
	private readonly _lowerRightY;
	private readonly _cornerWidth;
	private readonly _cornerHeight;
	constructor(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number, cornerWidth: number, cornerHeight: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableStrokeColor implements IDrawable {
	private readonly _color;
	constructor(color: IMagickColor);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableStrokeWidth implements IDrawable {
	private readonly _width;
	constructor(width: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextAlignment implements IDrawable {
	private readonly _alignment;
	constructor(alignment: TextAlignment);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextAntialias implements IDrawable {
	private readonly _isEnabled;
	private constructor();
	static get disabled(): DrawableTextAntialias;
	static get enabled(): DrawableTextAntialias;
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextDecoration implements IDrawable {
	private readonly _decoration;
	constructor(decoration: TextDecoration);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextInterlineSpacing implements IDrawable {
	private readonly _spacing;
	constructor(spacing: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextInterwordSpacing implements IDrawable {
	private readonly _spacing;
	constructor(spacing: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextKerning implements IDrawable {
	private readonly _kerning;
	constructor(kerning: number);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableTextUnderColor implements IDrawable {
	private readonly _color;
	constructor(color: IMagickColor);
	draw(wand: IDrawingWand): void;
}
export declare class DrawableText implements IDrawable {
	private readonly _x;
	private readonly _y;
	private readonly _value;
	constructor(x: number, y: number, value: string);
	draw(wand: IDrawingWand): void;
}
export declare const AlphaAction: {
	readonly Undefined: 0;
	readonly Activate: 1;
	readonly Associate: 2;
	readonly Background: 3;
	readonly Copy: 4;
	readonly Deactivate: 5;
	readonly Discrete: 6;
	readonly Disassociate: 7;
	readonly Extract: 8;
	readonly Off: 9;
	readonly On: 10;
	readonly Opaque: 11;
	readonly Remove: 12;
	readonly Set: 13;
	readonly Shape: 14;
	readonly Transparent: 15;
	readonly OffIfOpaque: 16;
};
export type AlphaAction = typeof AlphaAction[keyof typeof AlphaAction];
export declare const Channels: {
	readonly Undefined: 0;
	readonly Red: 1;
	readonly Gray: 1;
	readonly Cyan: 1;
	readonly Green: 2;
	readonly Magenta: 2;
	readonly Blue: 4;
	readonly Yellow: 4;
	readonly Black: 8;
	readonly Alpha: 16;
	readonly Opacity: 16;
	readonly Index: 32;
	readonly Composite: 31;
	readonly TrueAlpha: 256;
	readonly RGB: number;
	readonly CMYK: number;
	readonly CMYKA: number;
	readonly Meta0: number;
	readonly Meta1: number;
	readonly Meta2: number;
	readonly Meta3: number;
	readonly Meta4: number;
	readonly Meta5: number;
	readonly Meta6: number;
	readonly Meta7: number;
	readonly Meta8: number;
	readonly Meta9: number;
	readonly Meta10: number;
	readonly Meta11: number;
	readonly Meta12: number;
	readonly Meta13: number;
	readonly Meta14: number;
	readonly Meta15: number;
	readonly Meta16: number;
	readonly Meta17: number;
	readonly Meta18: number;
	readonly Meta19: number;
	readonly Meta20: number;
	readonly Meta21: number;
	readonly All: 134217727;
};
export type Channels = typeof Channels[keyof typeof Channels];
export declare const ColorSpace: {
	readonly Undefined: 0;
	readonly CMY: 1;
	readonly CMYK: 2;
	readonly Gray: 3;
	readonly HCL: 4;
	readonly HCLp: 5;
	readonly HSB: 6;
	readonly HSI: 7;
	readonly HSL: 8;
	readonly HSV: 9;
	readonly HWB: 10;
	readonly Lab: 11;
	readonly LCH: 12;
	readonly LCHab: 13;
	readonly LCHuv: 14;
	readonly Log: 15;
	readonly LMS: 16;
	readonly Luv: 17;
	readonly OHTA: 18;
	readonly Rec601YCbCr: 19;
	readonly Rec709YCbCr: 20;
	readonly RGB: 21;
	readonly scRGB: 22;
	readonly sRGB: 23;
	readonly Transparent: 24;
	readonly XyY: 25;
	readonly XYZ: 26;
	readonly YCbCr: 27;
	readonly YCC: 28;
	readonly YDbDr: 29;
	readonly YIQ: 30;
	readonly YPbPr: 31;
	readonly YUV: 32;
	readonly LinearGray: 33;
	readonly Jzazbz: 34;
	readonly DisplayP3: 35;
	readonly Adobe98: 36;
	readonly ProPhoto: 37;
	readonly Oklab: 38;
	readonly Oklch: 39;
	readonly CAT02LMSC: 40;
};
export type ColorSpace = typeof ColorSpace[keyof typeof ColorSpace];
export declare const ComplexOperator: {
	readonly Undefined: 0;
	readonly Add: 1;
	readonly Conjugate: 2;
	readonly Divide: 3;
	readonly MagnitudePhase: 4;
	readonly Multiply: 5;
	readonly RealImaginary: 6;
	readonly Subtract: 7;
};
export type ComplexOperator = typeof ComplexOperator[keyof typeof ComplexOperator];
export declare class ComplexSettings {
	constructor(complexOperator: ComplexOperator);
	readonly complexOperator: ComplexOperator;
	signalToNoiseRatio?: number;
}
export declare const EvaluateOperator: {
	readonly Undefined: 0;
	readonly Abs: 1;
	readonly Add: 2;
	readonly AddModulus: 3;
	readonly And: 4;
	readonly Cosine: 5;
	readonly Divide: 6;
	readonly Exponential: 7;
	readonly GaussianNoise: 8;
	readonly ImpulseNoise: 9;
	readonly LaplacianNoise: 10;
	readonly LeftShift: 11;
	readonly Log: 12;
	readonly Max: 13;
	readonly Mean: 14;
	readonly Median: 15;
	readonly Min: 16;
	readonly MultiplicativeNoise: 17;
	readonly Multiply: 18;
	readonly Or: 19;
	readonly PoissonNoise: 20;
	readonly Pow: 21;
	readonly RightShift: 22;
	readonly RootMeanSquare: 23;
	readonly Set: 24;
	readonly Sine: 25;
	readonly Subtract: 26;
	readonly Sum: 27;
	readonly ThresholdBlack: 28;
	readonly Threshold: 29;
	readonly ThresholdWhite: 30;
	readonly UniformNoise: 31;
	readonly Xor: 32;
	readonly InverseLog: 33;
};
export type EvaluateOperator = typeof EvaluateOperator[keyof typeof EvaluateOperator];
export declare class MagickErrorInfo {
	private constructor();
	readonly meanErrorPerPixel: number;
	readonly normalizedMaximumError: number;
	readonly normalizedMeanError: number;
}
export interface IMagickGeometry {
	readonly aspectRatio: boolean;
	fillArea: boolean;
	greater: boolean;
	height: number;
	ignoreAspectRatio: boolean;
	isPercentage: boolean;
	less: boolean;
	limitPixels: boolean;
	width: number;
	x: number;
	y: number;
}
export declare class MagickGeometry implements IMagickGeometry {
	private readonly _includeXyInToString;
	private _width;
	private _height;
	private _x;
	private _y;
	private _aspectRatio;
	private _fillArea;
	private _greater;
	private _isPercentage;
	private _ignoreAspectRatio;
	private _less;
	private _limitPixels;
	constructor(value: string);
	constructor(widthAndHeight: number);
	constructor(width: number, height: number);
	constructor(x: number, y: number, width: number, height: number);
	get aspectRatio(): boolean;
	get fillArea(): boolean;
	set fillArea(value: boolean);
	get greater(): boolean;
	set greater(value: boolean);
	get height(): number;
	set height(value: number);
	get ignoreAspectRatio(): boolean;
	set ignoreAspectRatio(value: boolean);
	get isPercentage(): boolean;
	set isPercentage(value: boolean);
	get less(): boolean;
	set less(value: boolean);
	get limitPixels(): boolean;
	set limitPixels(value: boolean);
	get width(): number;
	set width(value: number);
	get x(): number;
	set x(value: number);
	get y(): number;
	set y(value: number);
	toString(): string;
	private initialize;
	private initializeFromAspectRation;
	private parseNumber;
	private isNumber;
	private hasFlag;
}
export declare const ColorType: {
	readonly Undefined: 0;
	readonly Bilevel: 1;
	readonly Grayscale: 2;
	readonly GrayscaleAlpha: 3;
	readonly Palette: 4;
	readonly PaletteAlpha: 5;
	readonly TrueColor: 6;
	readonly TrueColorAlpha: 7;
	readonly ColorSeparation: 8;
	readonly ColorSeparationAlpha: 9;
	readonly Optimize: 10;
	readonly PaletteBilevelAlpha: 11;
};
export type ColorType = typeof ColorType[keyof typeof ColorType];
export declare const CompressionMethod: {
	readonly Undefined: 0;
	readonly B44A: 1;
	readonly B44: 2;
	readonly BZip: 3;
	readonly DXT1: 4;
	readonly DXT3: 5;
	readonly DXT5: 6;
	readonly Fax: 7;
	readonly Group4: 8;
	readonly JBIG1: 9;
	readonly JBIG2: 10;
	readonly JPEG2000: 11;
	readonly JPEG: 12;
	readonly LosslessJPEG: 13;
	readonly LZMA: 14;
	readonly LZW: 15;
	readonly NoCompression: 16;
	readonly Piz: 17;
	readonly Pxr24: 18;
	readonly RLE: 19;
	readonly Zip: 20;
	readonly ZipS: 21;
	readonly Zstd: 22;
	readonly WebP: 23;
	readonly DWAA: 24;
	readonly DWAB: 25;
	readonly BC7: 26;
	readonly BC5: 27;
};
export type CompressionMethod = typeof CompressionMethod[keyof typeof CompressionMethod];
export declare const DensityUnit: {
	readonly Undefined: 0;
	readonly PixelsPerInch: 1;
	readonly PixelsPerCentimeter: 2;
};
export type DensityUnit = typeof DensityUnit[keyof typeof DensityUnit];
export declare class Density {
	constructor(xy: number);
	constructor(xy: number, unit: DensityUnit);
	constructor(x: number, y: number, units: DensityUnit);
	readonly x: number;
	readonly y: number;
	readonly units: DensityUnit;
	toString(units?: DensityUnit): string;
	private static toString;
}
export declare const Endian: {
	readonly Undefined: 0;
	readonly LSB: 1;
	readonly MSB: 2;
};
export type Endian = typeof Endian[keyof typeof Endian];
export declare const Interlace: {
	readonly Undefined: 0;
	readonly NoInterlace: 1;
	readonly Line: 2;
	readonly Plane: 3;
	readonly Partition: 4;
	readonly Gif: 5;
	readonly Jpeg: 6;
	readonly Png: 7;
};
export type Interlace = typeof Interlace[keyof typeof Interlace];
export declare class MagickSettings {
	antiAlias?: boolean;
	backgroundColor?: IMagickColor;
	colorSpace?: ColorSpace;
	colorType?: ColorType;
	compression?: CompressionMethod;
	debug?: boolean;
	density?: Density;
	depth?: number;
	endian?: Endian;
	fillColor?: IMagickColor;
	font?: string;
	fontPointsize?: number;
	format?: MagickFormat;
	interlace?: Interlace;
	strokeColor?: IMagickColor;
	strokeWidth?: number;
	textInterlineSpacing?: number;
	textKerning?: number;
	getDefine(name: string): string | null;
	getDefine(format: MagickFormat, name: string): string | null;
	setDefine(name: string, value: string): void;
	setDefine(format: MagickFormat, name: string, value: string): void;
	setDefine(format: MagickFormat, name: string, value: number): void;
	setDefine(format: MagickFormat, name: string, value: boolean): void;
	setDefines(defines: IDefines): void;
	private parseDefine;
}
export declare class MagickReadSettings extends MagickSettings {
	constructor(partialSettings?: Partial<MagickReadSettings>);
	extractArea?: MagickGeometry;
	frameIndex?: number;
	frameCount?: number;
	height?: number;
	get syncImageWithExifProfile(): boolean;
	set syncImageWithExifProfile(value: boolean);
	get syncImageWithTiffProperties(): boolean;
	set syncImageWithTiffProperties(value: boolean);
	width?: number;
	private getSize;
}
export declare class MontageSettings {
	backgroundColor?: IMagickColor;
	borderColor?: IMagickColor;
	borderWidth?: number;
	fillColor?: IMagickColor;
	font?: string;
	fontPointsize?: number;
	frameGeometry?: IMagickGeometry;
	geometry?: IMagickGeometry;
	gravity?: Gravity;
	label?: string;
	shadow?: boolean;
	strokeColor?: IMagickColor;
	textureFileName?: string;
	tileGeometry?: IMagickGeometry;
	title?: string;
	transparentColor?: IMagickColor;
}
export declare const DitherMethod: {
	readonly Undefined: 0;
	readonly No: 1;
	readonly Riemersma: 2;
	readonly FloydSteinberg: 3;
};
export type DitherMethod = typeof DitherMethod[keyof typeof DitherMethod];
export declare class QuantizeSettings {
	constructor();
	colors: number;
	colorSpace: ColorSpace;
	ditherMethod?: DitherMethod;
	measureErrors: boolean;
	treeDepth: number;
}
export interface IMagickImageCollection extends Array<IMagickImage>, IDisposable {
	appendHorizontally<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	appendHorizontally<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	appendVertically<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	appendVertically<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	clone<TReturnType>(func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	clone<TReturnType>(func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	coalesce(): void;
	combine<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	combine<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	combine<TReturnType>(colorSpace: ColorSpace, func: SyncImageCallback<TReturnType>): TReturnType;
	combine<TReturnType>(colorSpace: ColorSpace, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	complex<TReturnType>(settings: ComplexSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	complex<TReturnType>(settings: ComplexSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	deconstruct(): void;
	evaluate<TReturnType>(evaluateOperator: EvaluateOperator, func: SyncImageCallback<TReturnType>): TReturnType;
	evaluate<TReturnType>(evaluateOperator: EvaluateOperator, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	flatten<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	flatten<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	fx<TReturnType>(expression: string, func: SyncImageCallback<TReturnType>): TReturnType;
	fx<TReturnType>(expression: string, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	fx<TReturnType>(expression: string, channels: Channels, func: SyncImageCallback<TReturnType>): TReturnType;
	fx<TReturnType>(expression: string, channels: Channels, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	merge<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	merge<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	montage<TReturnType>(settings: MontageSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	montage<TReturnType>(settings: MontageSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	morph(frames: number): void;
	mosaic<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	mosaic<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	optimize(): void;
	optimizePlus(): void;
	optimizeTransparency(): void;
	ping(fileName: string, settings?: MagickReadSettings): void;
	ping(array: ByteArray, settings?: MagickReadSettings): void;
	polynomial<TReturnType>(terms: number[], func: SyncImageCallback<TReturnType>): TReturnType;
	polynomial<TReturnType>(terms: number[], func: AsyncImageCallback<TReturnType>): TReturnType | Promise<TReturnType>;
	quantize(settings?: QuantizeSettings): MagickErrorInfo | null;
	read(fileName: string, settings?: MagickReadSettings): void;
	read(array: ByteArray, settings?: MagickReadSettings): void;
	remap(image: IMagickImage): void;
	remap(image: IMagickImage, settings: QuantizeSettings): void;
	resetPage(): void;
	smushHorizontal<TReturnType>(offset: number, func: SyncImageCallback<TReturnType>): TReturnType;
	smushHorizontal<TReturnType>(offset: number, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	smushVertical<TReturnType>(offset: number, func: SyncImageCallback<TReturnType>): TReturnType;
	smushVertical<TReturnType>(offset: number, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	trimBounds(): void;
	write<TReturnType>(func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
}
export declare class MagickImageCollection extends Array<MagickImage> implements IMagickImageCollection {
	private constructor();
	static create(): IMagickImageCollection;
	static create(array: ByteArray): IMagickImageCollection;
	dispose(): void;
	appendHorizontally<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	appendHorizontally<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	appendVertically<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	appendVertically<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	clone<TReturnType>(func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	clone<TReturnType>(func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	coalesce(): void;
	combine<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	combine<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	combine<TReturnType>(colorSpace: ColorSpace, func: SyncImageCallback<TReturnType>): TReturnType;
	combine<TReturnType>(colorSpace: ColorSpace, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	complex<TReturnType>(settings: ComplexSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	complex<TReturnType>(settings: ComplexSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	deconstruct(): void;
	evaluate<TReturnType>(evaluateOperator: EvaluateOperator, func: SyncImageCallback<TReturnType>): TReturnType;
	evaluate<TReturnType>(evaluateOperator: EvaluateOperator, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	flatten<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	flatten<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	fx<TReturnType>(expression: string, func: SyncImageCallback<TReturnType>): TReturnType;
	fx<TReturnType>(expression: string, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	fx<TReturnType>(expression: string, channels: Channels, func: SyncImageCallback<TReturnType>): TReturnType;
	fx<TReturnType>(expression: string, channels: Channels, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	merge<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	merge<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	montage<TReturnType>(settings: MontageSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	montage<TReturnType>(settings: MontageSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	morph(frames: number): void;
	mosaic<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	mosaic<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	optimize(): void;
	optimizePlus(): void;
	optimizeTransparency(): void;
	ping(fileName: string, settings?: MagickReadSettings): void;
	ping(array: ByteArray, settings?: MagickReadSettings): void;
	polynomial<TReturnType>(terms: number[], func: SyncImageCallback<TReturnType>): TReturnType;
	polynomial<TReturnType>(terms: number[], func: AsyncImageCallback<TReturnType>): TReturnType;
	quantize(settingsOrUndefined?: QuantizeSettings): MagickErrorInfo | null;
	read(fileName: string, settings?: MagickReadSettings): void;
	read(array: ByteArray, settings?: MagickReadSettings): void;
	remap(image: IMagickImage): void;
	remap(image: IMagickImage, settings: QuantizeSettings): void;
	resetPage(): void;
	smushHorizontal<TReturnType>(offset: number, func: SyncImageCallback<TReturnType>): TReturnType;
	smushHorizontal<TReturnType>(offset: number, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	smushVertical<TReturnType>(offset: number, func: SyncImageCallback<TReturnType>): TReturnType;
	smushVertical<TReturnType>(offset: number, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	trimBounds(): void;
	write<TReturnType>(func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	private addImages;
	private attachImages;
	private checkResult;
	private static createObject;
	private createImage;
	private getSettings;
	private mergeImages;
	private readOrPing;
	private replaceImages;
	private smush;
	private throwIfEmpty;
}
export type AsyncImageCallback<TReturnType> = (image: IMagickImage) => Promise<TReturnType>;
export type SyncImageCallback<TReturnType> = (image: IMagickImage) => TReturnType;
export type ImageCallback<TReturnType> = (image: IMagickImage) => TReturnType | Promise<TReturnType>;
export type AsyncImageCollectionCallback<TReturnType> = (images: IMagickImageCollection) => Promise<TReturnType>;
export type SyncImageCollectionCallback<TReturnType> = (images: IMagickImageCollection) => TReturnType;
export type ImageCollectionCallback<TReturnType> = (images: IMagickImageCollection) => TReturnType | Promise<TReturnType>;
export declare const AutoThresholdMethod: {
	readonly Undefined: 0;
	readonly Kapur: 1;
	readonly OTSU: 2;
	readonly Triangle: 3;
};
export type AutoThresholdMethod = typeof AutoThresholdMethod[keyof typeof AutoThresholdMethod];
export declare class PrimaryInfo {
	constructor(x: number, y: number, z: number);
	readonly x: number;
	readonly y: number;
	readonly z: number;
}
export declare class ChromaticityInfo {
	constructor(red: PrimaryInfo, green: PrimaryInfo, blue: PrimaryInfo, white: PrimaryInfo);
	readonly red: PrimaryInfo;
	readonly green: PrimaryInfo;
	readonly blue: PrimaryInfo;
	readonly white: PrimaryInfo;
}
export declare const ClassType: {
	readonly Undefined: 0;
	readonly Direct: 1;
	readonly Pseudo: 2;
};
export type ClassType = typeof ClassType[keyof typeof ClassType];
export interface IImageProfile {
	readonly name: string;
	readonly data: Uint8Array;
}
export declare class ImageProfile implements IImageProfile {
	constructor(name: string, data: Uint8Array);
	readonly name: string;
	readonly data: Uint8Array;
}
export interface IColorProfile extends IImageProfile {
	readonly colorSpace: ColorSpace;
	readonly copyright: string | null;
	readonly description: string | null;
	readonly manufacturer: string | null;
	readonly model: string | null;
}
export declare class ColorProfile extends ImageProfile implements IColorProfile {
	private _data?;
	constructor(data: Uint8Array);
	get colorSpace(): ColorSpace;
	get copyright(): string | null;
	get description(): string | null;
	get manufacturer(): string | null;
	get model(): string | null;
	private initialize;
}
export declare const ColorTransformMode: {
	readonly HighRes: 0;
	readonly Quantum: 1;
};
export type ColorTransformMode = typeof ColorTransformMode[keyof typeof ColorTransformMode];
export declare class CompareResult {
	private constructor();
	readonly difference: IMagickImage;
	readonly distortion: number;
}
export declare const ErrorMetric: {
	readonly Undefined: 0;
	readonly Absolute: 1;
	readonly Fuzz: 2;
	readonly MeanAbsolute: 3;
	readonly MeanErrorPerPixel: 4;
	readonly MeanSquared: 5;
	readonly NormalizedCrossCorrelation: 6;
	readonly PeakAbsolute: 7;
	readonly PeakSignalToNoiseRatio: 8;
	readonly PerceptualHash: 9;
	readonly RootMeanSquared: 10;
	readonly StructuralSimilarity: 11;
	readonly StructuralDissimilarity: 12;
};
export type ErrorMetric = typeof ErrorMetric[keyof typeof ErrorMetric];
export declare class CompareSettings {
	constructor(metric: ErrorMetric);
	readonly metric: ErrorMetric;
	highlightColor?: IMagickColor;
	lowlightColor?: IMagickColor;
	masklightColor?: IMagickColor;
}
export declare const CompositeOperator: {
	readonly Undefined: 0;
	readonly Alpha: 1;
	readonly Atop: 2;
	readonly Blend: 3;
	readonly Blur: 4;
	readonly Bumpmap: 5;
	readonly ChangeMask: 6;
	readonly Clear: 7;
	readonly ColorBurn: 8;
	readonly ColorDodge: 9;
	readonly Colorize: 10;
	readonly CopyBlack: 11;
	readonly CopyBlue: 12;
	readonly Copy: 13;
	readonly CopyCyan: 14;
	readonly CopyGreen: 15;
	readonly CopyMagenta: 16;
	readonly CopyAlpha: 17;
	readonly CopyRed: 18;
	readonly CopyYellow: 19;
	readonly Darken: 20;
	readonly DarkenIntensity: 21;
	readonly Difference: 22;
	readonly Displace: 23;
	readonly Dissolve: 24;
	readonly Distort: 25;
	readonly DivideDst: 26;
	readonly DivideSrc: 27;
	readonly DstAtop: 28;
	readonly Dst: 29;
	readonly DstIn: 30;
	readonly DstOut: 31;
	readonly DstOver: 32;
	readonly Exclusion: 33;
	readonly HardLight: 34;
	readonly HardMix: 35;
	readonly Hue: 36;
	readonly In: 37;
	readonly Intensity: 38;
	readonly Lighten: 39;
	readonly LightenIntensity: 40;
	readonly LinearBurn: 41;
	readonly LinearDodge: 42;
	readonly LinearLight: 43;
	readonly Luminize: 44;
	readonly Mathematics: 45;
	readonly MinusDst: 46;
	readonly MinusSrc: 47;
	readonly Modulate: 48;
	readonly ModulusAdd: 49;
	readonly ModulusSubtract: 50;
	readonly Multiply: 51;
	readonly No: 52;
	readonly Out: 53;
	readonly Over: 54;
	readonly Overlay: 55;
	readonly PegtopLight: 56;
	readonly PinLight: 57;
	readonly Plus: 58;
	readonly Replace: 59;
	readonly Saturate: 60;
	readonly Screen: 61;
	readonly SoftLight: 62;
	readonly SrcAtop: 63;
	readonly Src: 64;
	readonly SrcIn: 65;
	readonly SrcOut: 66;
	readonly SrcOver: 67;
	readonly Threshold: 68;
	readonly VividLight: 69;
	readonly Xor: 70;
	readonly Stereo: 71;
	readonly Freeze: 72;
	readonly Interpolate: 73;
	readonly Negate: 74;
	readonly Reflect: 75;
	readonly SoftBurn: 76;
	readonly SoftDodge: 77;
	readonly Stamp: 78;
	readonly RMSE: 79;
	readonly SaliencyBlend: 80;
	readonly SeamlessBlend: 81;
};
export type CompositeOperator = typeof CompositeOperator[keyof typeof CompositeOperator];
export declare class Point {
	constructor(xy: number);
	constructor(x: number, y: number);
	readonly x: number;
	readonly y: number;
}
export declare class ConnectedComponent {
	private constructor();
	readonly area: number;
	readonly centroid: Point;
	readonly color?: IMagickColor;
	readonly height: number;
	readonly id: number;
	readonly width: number;
	readonly x: number;
	readonly y: number;
	toGeometry(): IMagickGeometry;
}
export declare class Threshold {
	constructor(minimum: number, maximum?: number);
	readonly minimum: number;
	readonly maximum: number;
	toString(): string;
}
export type Connectivity = 4 | 8;
export declare class ConnectedComponentsSettings {
	angleThreshold?: Threshold;
	areaThreshold?: Threshold;
	circularityThreshold?: Threshold;
	connectivity: Connectivity;
	diameterThreshold?: Threshold;
	eccentricityThreshold?: Threshold;
	majorAxisThreshold?: Threshold;
	meanColor?: boolean;
	minorAxisThreshold?: Threshold;
	perimeterThreshold?: Threshold;
	constructor(connectivity: Connectivity);
}
export declare const DistortMethod: {
	readonly Undefined: 0;
	readonly Affine: 1;
	readonly AffineProjection: 2;
	readonly ScaleRotateTranslate: 3;
	readonly Perspective: 4;
	readonly PerspectiveProjection: 5;
	readonly BilinearForward: 6;
	readonly BilinearReverse: 7;
	readonly Polynomial: 8;
	readonly Arc: 9;
	readonly Polar: 10;
	readonly DePolar: 11;
	readonly Cylinder2Plane: 12;
	readonly Plane2Cylinder: 13;
	readonly Barrel: 14;
	readonly BarrelInverse: 15;
	readonly Shepards: 16;
	readonly Resize: 17;
	readonly Sentinel: 18;
	readonly RigidAffine: 19;
};
export type DistortMethod = typeof DistortMethod[keyof typeof DistortMethod];
export declare class DistortSettings {
	constructor(method: DistortMethod);
	readonly method: DistortMethod;
	bestFit: boolean;
	scale?: number;
	viewport?: IMagickGeometry;
}
export declare const FilterType: {
	readonly Undefined: 0;
	readonly Point: 1;
	readonly Box: 2;
	readonly Triangle: 3;
	readonly Hermite: 4;
	readonly Hann: 5;
	readonly Hamming: 6;
	readonly Blackman: 7;
	readonly Gaussian: 8;
	readonly Quadratic: 9;
	readonly Cubic: 10;
	readonly Catrom: 11;
	readonly Mitchell: 12;
	readonly Jinc: 13;
	readonly Sinc: 14;
	readonly SincFast: 15;
	readonly Kaiser: 16;
	readonly Welch: 17;
	readonly Parzen: 18;
	readonly Bohman: 19;
	readonly Bartlett: 20;
	readonly Lagrange: 21;
	readonly Lanczos: 22;
	readonly LanczosSharp: 23;
	readonly Lanczos2: 24;
	readonly Lanczos2Sharp: 25;
	readonly Robidoux: 26;
	readonly RobidouxSharp: 27;
	readonly Cosine: 28;
	readonly Spline: 29;
	readonly LanczosRadius: 30;
	readonly CubicSpline: 31;
};
export type FilterType = typeof FilterType[keyof typeof FilterType];
export declare const GifDisposeMethod: {
	readonly Undefined: 0;
	readonly None: 1;
	readonly Background: 2;
	readonly Previous: 3;
};
export type GifDisposeMethod = typeof GifDisposeMethod[keyof typeof GifDisposeMethod];
export declare const Kernel: {
	readonly Undefined: "Undefined";
	readonly Unity: "Unity";
	readonly Gaussian: "Gaussian";
	readonly DoG: "DoG";
	readonly LoG: "LoG";
	readonly Blur: "Blur";
	readonly Comet: "Comet";
	readonly Binomial: "Binomial";
	readonly Laplacian: "Laplacian";
	readonly Sobel: "Sobel";
	readonly FreiChen: "FreiChen";
	readonly Roberts: "Roberts";
	readonly Prewitt: "Prewitt";
	readonly Compass: "Compass";
	readonly Kirsch: "Kirsch";
	readonly Diamond: "Diamond";
	readonly Square: "Square";
	readonly Rectangle: "Rectangle";
	readonly Octagon: "Octagon";
	readonly Disk: "Disk";
	readonly Plus: "Plus";
	readonly Cross: "Cross";
	readonly Ring: "Ring";
	readonly Peaks: "Peaks";
	readonly Edges: "Edges";
	readonly Corners: "Corners";
	readonly Diagonals: "Diagonals";
	readonly LineEnds: "LineEnds";
	readonly LineJunctions: "LineJunctions";
	readonly Ridges: "Ridges";
	readonly ConvexHull: "ConvexHull";
	readonly ThinSE: "ThinSE";
	readonly Skeleton: "Skeleton";
	readonly Chebyshev: "Chebyshev";
	readonly Manhattan: "Manhattan";
	readonly Octagonal: "Octagonal";
	readonly Euclidean: "Euclidean";
	readonly UserDefined: "UserDefined";
};
export type Kernel = typeof Kernel[keyof typeof Kernel];
export declare const MorphologyMethod: {
	readonly Undefined: 0;
	readonly Convolve: 1;
	readonly Correlate: 2;
	readonly Erode: 3;
	readonly Dilate: 4;
	readonly ErodeIntensity: 5;
	readonly DilateIntensity: 6;
	readonly IterativeDistance: 7;
	readonly Open: 8;
	readonly Close: 9;
	readonly OpenIntensity: 10;
	readonly CloseIntensity: 11;
	readonly Smooth: 12;
	readonly EdgeIn: 13;
	readonly EdgeOut: 14;
	readonly Edge: 15;
	readonly TopHat: 16;
	readonly BottomHat: 17;
	readonly HitAndMiss: 18;
	readonly Thinning: 19;
	readonly Thicken: 20;
	readonly Distance: 21;
	readonly Voronoi: 22;
};
export type MorphologyMethod = typeof MorphologyMethod[keyof typeof MorphologyMethod];
export declare class MorphologySettings {
	constructor(method: MorphologyMethod, kernel: Kernel | string, args?: string);
	channels: Channels;
	convolveBias: Percentage | undefined;
	convolveScale: IMagickGeometry | undefined;
	iterations: number;
	readonly kernel: string;
	readonly method: MorphologyMethod;
}
export declare const Orientation: {
	readonly Undefined: 0;
	readonly TopLeft: 1;
	readonly TopRight: 2;
	readonly BottomRight: 3;
	readonly BottomLeft: 4;
	readonly LeftTop: 5;
	readonly RightTop: 6;
	readonly RightBottom: 7;
	readonly LeftBottom: 8;
};
export type Orientation = typeof Orientation[keyof typeof Orientation];
export declare const NoiseType: {
	readonly Undefined: 0;
	readonly Uniform: 1;
	readonly Gaussian: 2;
	readonly MultiplicativeGaussian: 3;
	readonly Impulse: 4;
	readonly Laplacian: 5;
	readonly Poisson: 6;
	readonly Random: 7;
};
export type NoiseType = typeof NoiseType[keyof typeof NoiseType];
export declare const PixelChannel: {
	readonly Red: 0;
	readonly Cyan: 0;
	readonly Gray: 0;
	readonly Green: 1;
	readonly Magenta: 1;
	readonly Blue: 2;
	readonly Yellow: 2;
	readonly Black: 3;
	readonly Alpha: 4;
	readonly Index: 5;
	readonly Meta0: 10;
	readonly Meta1: 11;
	readonly Meta2: 12;
	readonly Meta3: 13;
	readonly Meta4: 14;
	readonly Meta5: 15;
	readonly Meta6: 16;
	readonly Meta7: 17;
	readonly Meta8: 18;
	readonly Meta9: 19;
	readonly Meta10: 20;
	readonly Meta11: 21;
	readonly Meta12: 22;
	readonly Meta13: 23;
	readonly Meta14: 24;
	readonly Meta15: 25;
	readonly Meta16: 26;
	readonly Meta17: 27;
	readonly Meta18: 28;
	readonly Meta19: 29;
	readonly Meta20: 30;
	readonly Meta21: 31;
	readonly Meta22: 32;
	readonly Meta23: 33;
	readonly Meta24: 34;
	readonly Meta25: 35;
	readonly Meta26: 36;
	readonly Meta27: 37;
	readonly Meta28: 38;
	readonly Meta29: 39;
	readonly Meta30: 40;
	readonly Meta31: 41;
	readonly Meta32: 42;
	readonly Meta33: 43;
	readonly Meta34: 44;
	readonly Meta35: 45;
	readonly Meta36: 46;
	readonly Meta37: 47;
	readonly Meta38: 48;
	readonly Meta39: 49;
	readonly Meta40: 50;
	readonly Meta41: 51;
	readonly Meta42: 52;
	readonly Meta43: 53;
	readonly Meta44: 54;
	readonly Meta45: 55;
	readonly Meta46: 56;
	readonly Meta47: 57;
	readonly Meta48: 58;
	readonly Meta49: 59;
	readonly Meta50: 60;
	readonly Meta51: 61;
	readonly Meta52: 62;
	readonly Composite: 64;
};
export type PixelChannel = typeof PixelChannel[keyof typeof PixelChannel];
export interface IChannelPerceptualHash {
	readonly channel: PixelChannel;
	huPhash(colorSpace: ColorSpace, channelIndex: number): number;
	sumSquaredDistance(other: IChannelPerceptualHash): number;
	toString(): string;
}
export declare class ChannelPerceptualHash implements IChannelPerceptualHash {
	private readonly _huPhashes;
	private _hash;
	channel: PixelChannel;
	constructor(channel: PixelChannel, colorSpaces: ReadonlyArray<ColorSpace>, instance: number);
	huPhash(colorSpace: ColorSpace, index: number): number;
	sumSquaredDistance(other: IChannelPerceptualHash): number;
	toString(): string;
	private parseHash;
	private static powerOfTen;
	private setHash;
}
export interface IPerceptualHash {
	getChannel(channel: number): IChannelPerceptualHash | null;
	sumSquaredDistance(other: IPerceptualHash): number;
	toString(): string;
}
export type quantumArray = Uint8Array;
export interface IPixelCollection extends IDisposable {
	getArea(x: number, y: number, width: number, height: number): quantumArray;
	getPixel(x: number, y: number): quantumArray;
	setArea(x: number, y: number, width: number, height: number, quantumPixels: quantumArray): void;
	setArea(x: number, y: number, width: number, height: number, numberPixels: number[]): void;
	setPixel(x: number, y: number, quantumPixels: quantumArray): void;
	setPixel(x: number, y: number, numberPixels: number[]): void;
	toByteArray(x: number, y: number, width: number, height: number, mapping: string): Uint8Array | null;
}
export declare class PixelCollection extends NativeInstance implements IPixelCollection {
	private readonly image;
	private constructor();
	getArea(x: number, y: number, width: number, height: number): quantumArray;
	getPixel(x: number, y: number): quantumArray;
	setArea(x: number, y: number, width: number, height: number, quantumPixels: quantumArray): void;
	setArea(x: number, y: number, width: number, height: number, numberPixels: number[]): void;
	setPixel(x: number, y: number, quantumPixels: quantumArray): void;
	setPixel(x: number, y: number, numberPixels: number[]): void;
	toByteArray(x: number, y: number, width: number, height: number, mapping: string): Uint8Array | null;
	private use;
}
export declare const PixelIntensityMethod: {
	readonly Undefined: 0;
	readonly Average: 1;
	readonly Brightness: 2;
	readonly Lightness: 3;
	readonly MS: 4;
	readonly Rec601Luma: 5;
	readonly Rec601Luminance: 6;
	readonly Rec709Luma: 7;
	readonly Rec709Luminance: 8;
	readonly RMS: 9;
};
export type PixelIntensityMethod = typeof PixelIntensityMethod[keyof typeof PixelIntensityMethod];
export declare const PixelInterpolateMethod: {
	readonly Undefined: 0;
	readonly Average: 1;
	readonly Average9: 2;
	readonly Average16: 3;
	readonly Background: 4;
	readonly Bilinear: 5;
	readonly Blend: 6;
	readonly Catrom: 7;
	readonly Integer: 8;
	readonly Mesh: 9;
	readonly Nearest: 10;
	readonly Spline: 11;
};
export type PixelInterpolateMethod = typeof PixelInterpolateMethod[keyof typeof PixelInterpolateMethod];
declare class ProgressEvent$1 {
	readonly origin: string | null;
	readonly progress: Percentage;
	cancel: boolean;
}
export declare const RenderingIntent: {
	readonly Undefined: 0;
	readonly Saturation: 1;
	readonly Perceptual: 2;
	readonly Absolute: 3;
	readonly Relative: 4;
};
export type RenderingIntent = typeof RenderingIntent[keyof typeof RenderingIntent];
export interface IChannelStatistics {
	readonly channel: PixelChannel;
	readonly depth: number;
	readonly entropy: number;
	readonly kurtosis: number;
	readonly maximum: number;
	readonly mean: number;
	readonly minimum: number;
	readonly skewness: number;
	readonly standardDeviation: number;
}
export interface IStatistics {
	readonly channels: ReadonlyArray<PixelChannel>;
	composite(): IChannelStatistics;
	getChannel(channel: PixelChannel): IChannelStatistics | null;
}
export declare const VirtualPixelMethod: {
	readonly Undefined: 0;
	readonly Background: 1;
	readonly Dither: 2;
	readonly Edge: 3;
	readonly Mirror: 4;
	readonly Random: 5;
	readonly Tile: 6;
	readonly Transparent: 7;
	readonly Mask: 8;
	readonly Black: 9;
	readonly Gray: 10;
	readonly White: 11;
	readonly HorizontalTile: 12;
	readonly VerticalTile: 13;
	readonly HorizontalTileEdge: 14;
	readonly VerticalTileEdge: 15;
	readonly CheckerTile: 16;
};
export type VirtualPixelMethod = typeof VirtualPixelMethod[keyof typeof VirtualPixelMethod];
export declare const MagickErrorSeverity: {
	readonly Warning: 300;
	readonly ResourceLimitWarning: 300;
	readonly TypeWarning: 305;
	readonly OptionWarning: 310;
	readonly DelegateWarning: 315;
	readonly MissingDelegateWarning: 320;
	readonly CorruptImageWarning: 325;
	readonly FileOpenWarning: 330;
	readonly BlobWarning: 335;
	readonly StreamWarning: 340;
	readonly CacheWarning: 345;
	readonly CoderWarning: 350;
	readonly FilterWarning: 352;
	readonly ModuleWarning: 355;
	readonly DrawWarning: 360;
	readonly ImageWarning: 365;
	readonly WandWarning: 370;
	readonly RandomWarning: 375;
	readonly XServerWarning: 380;
	readonly MonitorWarning: 385;
	readonly RegistryWarning: 390;
	readonly ConfigureWarning: 395;
	readonly PolicyWarning: 399;
	readonly Error: 400;
	readonly ResourceLimitError: 400;
	readonly TypeError: 405;
	readonly OptionError: 410;
	readonly DelegateError: 415;
	readonly MissingDelegateError: 420;
	readonly CorruptImageError: 425;
	readonly FileOpenError: 430;
	readonly BlobError: 435;
	readonly StreamError: 440;
	readonly CacheError: 445;
	readonly CoderError: 450;
	readonly FilterError: 452;
	readonly ModuleError: 455;
	readonly DrawError: 460;
	readonly ImageError: 465;
	readonly WandError: 470;
	readonly RandomError: 475;
	readonly XServerError: 480;
	readonly MonitorError: 485;
	readonly RegistryError: 490;
	readonly ConfigureError: 495;
	readonly PolicyError: 499;
};
export type MagickErrorSeverity = typeof MagickErrorSeverity[keyof typeof MagickErrorSeverity];
export declare class MagickError extends Error {
	private _relatedErrors;
	readonly severity: MagickErrorSeverity;
	get relatedErrors(): ReadonlyArray<MagickError>;
}
export declare class WarningEvent {
	readonly error: MagickError;
}
export interface IMagickImage extends IDisposable {
	animationDelay: number;
	animationIterations: number;
	animationTicksPerSecond: number;
	readonly artifactNames: ReadonlyArray<string>;
	readonly attributeNames: ReadonlyArray<string>;
	backgroundColor: IMagickColor;
	readonly baseHeight: number;
	readonly baseWidth: number;
	blackPointCompensation: boolean;
	borderColor: IMagickColor;
	boundingBox: IMagickGeometry | null;
	readonly channelCount: number;
	readonly channels: ReadonlyArray<PixelChannel>;
	chromaticity: ChromaticityInfo;
	classType: ClassType;
	colorFuzz: Percentage;
	colormapSize: number;
	colorSpace: ColorSpace;
	colorType: ColorType;
	comment: string | null;
	compose: CompositeOperator;
	readonly compression: CompressionMethod;
	density: Density;
	depth: number;
	endian: Endian;
	readonly fileName: string | null;
	filterType: FilterType;
	format: MagickFormat;
	gamma: number;
	gifDisposeMethod: GifDisposeMethod;
	hasAlpha: boolean;
	readonly height: number;
	readonly interlace: Interlace;
	interpolate: PixelInterpolateMethod;
	readonly isOpaque: boolean;
	label: string | null;
	matteColor: IMagickColor;
	metaChannelCount: number;
	orientation: Orientation;
	onProgress?: (event: ProgressEvent$1) => void;
	onWarning?: (event: WarningEvent) => void;
	page: IMagickGeometry;
	readonly profileNames: ReadonlyArray<string>;
	quality: number;
	renderingIntent: RenderingIntent;
	readonly settings: MagickSettings;
	readonly signature: string | null;
	readonly totalColors: number;
	virtualPixelMethod: VirtualPixelMethod;
	width: number;
	adaptiveBlur(): void;
	adaptiveBlur(radius: number): void;
	adaptiveBlur(radius: number, sigma: number): void;
	adaptiveResize(geometry: IMagickGeometry): void;
	adaptiveResize(width: number, height: number): void;
	adaptiveSharpen(): void;
	adaptiveSharpen(channels: Channels): void;
	adaptiveSharpen(radius: number, sigma: number): void;
	adaptiveSharpen(radius: number, sigma: number, channels: Channels): void;
	adaptiveThreshold(width: number, height: number): void;
	adaptiveThreshold(width: number, height: number, channels: Channels): void;
	adaptiveThreshold(width: number, height: number, bias: Percentage): void;
	adaptiveThreshold(width: number, height: number, bias: Percentage, channels: Channels): void;
	addNoise(noiseType: NoiseType): void;
	addNoise(noiseType: NoiseType, channels: Channels): void;
	addNoise(noiseType: NoiseType, attenuate: number): void;
	addNoise(noiseType: NoiseType, attenuate: number, channels: Channels): void;
	alpha(value: AlphaAction): void;
	annotate(text: string, boundingArea: MagickGeometry): void;
	annotate(text: string, boundingArea: MagickGeometry, gravity: Gravity): void;
	annotate(text: string, boundingArea: MagickGeometry, gravity: Gravity, angle: number): void;
	annotate(text: string, gravity: Gravity): void;
	annotate(text: string, gravity: Gravity, angle: number): void;
	autoGamma(): void;
	autoGamma(channels: Channels): void;
	autoLevel(): void;
	autoLevel(channels: Channels): void;
	autoOrient(): void;
	autoThreshold(method: AutoThresholdMethod): void;
	bilateralBlur(width: number, height: number): void;
	bilateralBlur(width: number, height: number, intensitySigma: number, spatialSigma: number): void;
	blackThreshold(threshold: Percentage): void;
	blackThreshold(threshold: Percentage, channels: Channels): void;
	blueShift(): void;
	blueShift(factor: number): void;
	blur(): void;
	blur(channels: Channels): void;
	blur(radius: number, sigma: number): void;
	blur(radius: number, sigma: number, channels: Channels): void;
	border(size: number): void;
	border(width: number, height: number): void;
	brightnessContrast(brightness: Percentage, contrast: Percentage): void;
	brightnessContrast(brightness: Percentage, contrast: Percentage, channels: Channels): void;
	cannyEdge(): void;
	cannyEdge(radius: number, sigma: number, lower: Percentage, upper: Percentage): void;
	charcoal(): void;
	charcoal(radius: number, sigma: number): void;
	chop(geometry: MagickGeometry): void;
	chopHorizontal(x: number, width: number): void;
	chopVertical(y: number, height: number): void;
	clahe(xTiles: number, yTiles: number, numberBins: number, clipLimit: number): void;
	clahe(xTiles: Percentage, yTiles: Percentage, numberBins: number, clipLimit: number): void;
	clone<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	clone<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	cloneArea<TReturnType>(geometry: MagickGeometry, func: SyncImageCallback<TReturnType>): TReturnType;
	cloneArea<TReturnType>(geometry: MagickGeometry, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	colorAlpha(color: IMagickColor): void;
	compare(image: IMagickImage, metric: ErrorMetric): number;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, channels: Channels, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, channels: Channels, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare(image: IMagickImage, metric: ErrorMetric, channels: Channels): number;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, channels: Channels, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, channels: Channels, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	composite(image: IMagickImage): void;
	composite(image: IMagickImage, compose: CompositeOperator): void;
	composite(image: IMagickImage, compose: CompositeOperator, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, args: string): void;
	composite(image: IMagickImage, compose: CompositeOperator, args: string, channels: Channels): void;
	composite(image: IMagickImage, point: Point): void;
	composite(image: IMagickImage, point: Point, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, args: string): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, args: string, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, args: string): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, args: string, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, point: Point): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, point: Point, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, args: string): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, args: string, channels: Channels): void;
	connectedComponents(connectivity: Connectivity): ConnectedComponent[];
	connectedComponents(settings: ConnectedComponentsSettings): ConnectedComponent[];
	contrast(): void;
	contrastStretch(blackPoint: Percentage): void;
	contrastStretch(blackPoint: Percentage, channels: Channels): void;
	contrastStretch(blackPoint: Percentage, whitePoint: Percentage): void;
	contrastStretch(blackPoint: Percentage, whitePoint: Percentage, channels: Channels): void;
	crop(geometry: IMagickGeometry): void;
	crop(geometry: IMagickGeometry, gravity: Gravity): void;
	crop(width: number, height: number): void;
	crop(width: number, height: number, gravity: Gravity): void;
	cropToTiles<TReturnType>(geometry: IMagickGeometry, func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	cropToTiles<TReturnType>(geometry: IMagickGeometry, func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	cropToTiles<TReturnType>(width: number, height: number, func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	cropToTiles<TReturnType>(width: number, height: number, func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	deskew(threshold: Percentage): number;
	deskew(threshold: Percentage, autoCrop: boolean): number;
	distort(method: DistortMethod, params: number[]): void;
	distort(settings: DistortSettings, params: number[]): void;
	draw(drawables: IDrawable[]): void;
	draw(...drawables: IDrawable[]): void;
	evaluate(channels: Channels, operator: EvaluateOperator, value: number): void;
	evaluate(channels: Channels, operator: EvaluateOperator, value: Percentage): void;
	evaluate(channels: Channels, geometry: IMagickGeometry, operator: EvaluateOperator, value: number): void;
	evaluate(channels: Channels, geometry: IMagickGeometry, operator: EvaluateOperator, value: Percentage): void;
	extent(width: number, height: number): void;
	extent(width: number, height: number, gravity: Gravity): void;
	extent(width: number, height: number, backgroundColor: IMagickColor): void;
	extent(geometry: IMagickGeometry): void;
	extent(geometry: IMagickGeometry, gravity: Gravity): void;
	extent(geometry: IMagickGeometry, gravity: Gravity, backgroundColor: IMagickColor): void;
	extent(geometry: IMagickGeometry, backgroundColor: IMagickColor): void;
	flip(): void;
	flop(): void;
	formatExpression(expression: string): string | null;
	gammaCorrect(gamma: number): void;
	gammaCorrect(gamma: number, channels: Channels): void;
	gaussianBlur(radius: number): void;
	gaussianBlur(radius: number, sigma: number): void;
	gaussianBlur(radius: number, sigma: number, channels: Channels): void;
	getArtifact(name: string): string | null;
	getAttribute(name: string): string | null;
	getColorProfile(): IColorProfile | null;
	getPixels<TReturnType>(func: (pixels: IPixelCollection) => TReturnType): TReturnType;
	getPixels<TReturnType>(func: (pixels: IPixelCollection) => Promise<TReturnType>): Promise<TReturnType>;
	getProfile(name: string): IImageProfile | null;
	getWriteMask<TReturnType>(func: (mask: IMagickImage | null) => TReturnType): TReturnType;
	getWriteMask<TReturnType>(func: (mask: IMagickImage | null) => Promise<TReturnType>): Promise<TReturnType>;
	grayscale(): void;
	grayscale(method: PixelIntensityMethod): void;
	hasProfile(name: string): boolean;
	histogram(): Map<string, number>;
	inverseContrast(): void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage): void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage, gamma: number): void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage, gamma: number, channels: Channels): void;
	inverseOpaque(target: IMagickColor, fill: IMagickColor): void;
	inverseSigmoidalContrast(contrast: number): void;
	inverseSigmoidalContrast(contrast: number, midpoint: Percentage): void;
	inverseSigmoidalContrast(contrast: number, midpoint: number): void;
	inverseSigmoidalContrast(contrast: number, midpoint: number, channels: Channels): void;
	inverseTransparent(color: IMagickColor): void;
	level(blackPoint: Percentage, whitePoint: Percentage): void;
	level(blackPoint: Percentage, whitePoint: Percentage, gamma: number): void;
	level(blackPoint: Percentage, whitePoint: Percentage, gamma: number, channels: Channels): void;
	linearStretch(blackPoint: Percentage, whitePoint: Percentage): void;
	liquidRescale(geometry: IMagickGeometry): void;
	liquidRescale(width: number, height: number): void;
	modulate(brightness: Percentage): void;
	modulate(brightness: Percentage, saturation: Percentage): void;
	modulate(brightness: Percentage, saturation: Percentage, hue: Percentage): void;
	morphology(settings: MorphologySettings): void;
	motionBlur(radius: number, sigma: number, angle: number): void;
	negate(): void;
	negate(channels: Channels): void;
	negateGrayScale(): void;
	negateGrayScale(channels: Channels): void;
	normalize(): void;
	oilPaint(): void;
	oilPaint(radius: number): void;
	opaque(target: IMagickColor, fill: IMagickColor): void;
	perceptualHash(): IPerceptualHash;
	perceptualHash(colorSpaces: ReadonlyArray<ColorSpace>): IPerceptualHash;
	ping(fileName: string, settings?: MagickReadSettings): void;
	ping(array: ByteArray, settings?: MagickReadSettings): void;
	quantize(settings?: QuantizeSettings): MagickErrorInfo | null;
	read(color: IMagickColor, width: number, height: number): void;
	read(fileName: string, settings?: MagickReadSettings): void;
	read(array: ByteArray, settings?: MagickReadSettings): void;
	readFromCanvas(canvas: HTMLCanvasElement, settings?: CanvasRenderingContext2DSettings): void;
	removeArtifact(name: string): void;
	removeAttribute(name: string): void;
	removeProfile(profile: IImageProfile): void;
	removeProfile(name: string): void;
	removeWriteMask(): void;
	resetPage(): void;
	resize(geometry: IMagickGeometry): void;
	resize(width: number, height: number): void;
	rotate(degrees: number): void;
	separate<TReturnType>(func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	separate<TReturnType>(func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	separate<TReturnType>(channels: Channels, func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	separate<TReturnType>(channels: Channels, func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	sepiaTone(): void;
	sepiaTone(threshold: number): void;
	sepiaTone(threshold: Percentage): void;
	setArtifact(name: string, value: boolean | IMagickColor | number | string): void;
	setAttribute(name: string, value: string): void;
	setProfile(profile: IImageProfile): void;
	setProfile(name: string, data: ByteArray): void;
	setWriteMask(image: IMagickImage): void;
	sharpen(): void;
	sharpen(radius: number, sigma: number): void;
	sharpen(radius: number, sigma: number, channels: Channels): void;
	shave(leftRight: number, topBottom: number): void;
	sigmoidalContrast(contrast: number): void;
	sigmoidalContrast(contrast: number, midpoint: Percentage): void;
	sigmoidalContrast(contrast: number, midpoint: number): void;
	sigmoidalContrast(contrast: number, midpoint: number, channels: Channels): void;
	solarize(): void;
	solarize(factor: number): void;
	solarize(factor: Percentage): void;
	splice(geometry: IMagickGeometry): void;
	statistics(): IStatistics;
	statistics(channels: Channels): IStatistics;
	strip(): void;
	transformColorSpace(target: IColorProfile): boolean;
	transformColorSpace(target: IColorProfile, mode: ColorTransformMode): boolean;
	transformColorSpace(source: IColorProfile, target: IColorProfile): boolean;
	transformColorSpace(source: IColorProfile, target: IColorProfile, mode: ColorTransformMode): boolean;
	threshold(percentage: Percentage): void;
	threshold(percentage: Percentage, channels: Channels): void;
	thumbnail(width: number, height: number): void;
	thumbnail(geometry: IMagickGeometry): void;
	toString(): string;
	transparent(color: IMagickColor): void;
	trim(): void;
	trim(...edges: Gravity[]): void;
	trim(percentage: Percentage): void;
	vignette(): void;
	vignette(radius: number, sigma: number, x: number, y: number): void;
	wave(): void;
	wave(method: PixelInterpolateMethod, amplitude: number, length: number): void;
	whiteThreshold(threshold: Percentage): void;
	whiteThreshold(threshold: Percentage, channels: Channels): void;
	write<TReturnType>(func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	writeToCanvas(canvas: HTMLCanvasElement, settings?: CanvasRenderingContext2DSettings): void;
}
export declare class MagickImage extends NativeInstance implements IMagickImage {
	private readonly _settings;
	private _progress?;
	private _warning?;
	private constructor();
	get animationDelay(): number;
	set animationDelay(value: number);
	get animationIterations(): number;
	set animationIterations(value: number);
	get animationTicksPerSecond(): number;
	set animationTicksPerSecond(value: number);
	get artifactNames(): ReadonlyArray<string>;
	get attributeNames(): ReadonlyArray<string>;
	get backgroundColor(): IMagickColor;
	set backgroundColor(value: IMagickColor);
	get baseHeight(): number;
	get baseWidth(): number;
	get blackPointCompensation(): boolean;
	set blackPointCompensation(value: boolean);
	get borderColor(): IMagickColor;
	set borderColor(value: IMagickColor);
	get boundingBox(): IMagickGeometry | null;
	get channelCount(): number;
	get channels(): ReadonlyArray<PixelChannel>;
	get chromaticity(): ChromaticityInfo;
	set chromaticity(value: ChromaticityInfo);
	get classType(): ClassType;
	set classType(value: ClassType);
	get colorFuzz(): Percentage;
	set colorFuzz(value: Percentage);
	get colormapSize(): number;
	set colormapSize(value: number);
	get colorSpace(): ColorSpace;
	set colorSpace(value: ColorSpace);
	get colorType(): ColorType;
	set colorType(value: ColorType);
	get comment(): string | null;
	set comment(value: string | null);
	get compose(): CompositeOperator;
	set compose(value: CompositeOperator);
	get compression(): CompressionMethod;
	get density(): Density;
	set density(value: Density);
	get depth(): number;
	set depth(value: number);
	get endian(): Endian;
	set endian(value: Endian);
	get fileName(): string | null;
	get filterType(): FilterType;
	set filterType(value: FilterType);
	get format(): MagickFormat;
	set format(value: MagickFormat);
	get gamma(): number;
	get gifDisposeMethod(): GifDisposeMethod;
	set gifDisposeMethod(value: GifDisposeMethod);
	get hasAlpha(): boolean;
	set hasAlpha(value: boolean);
	get height(): number;
	get interlace(): Interlace;
	get isOpaque(): boolean;
	get interpolate(): PixelInterpolateMethod;
	set interpolate(value: PixelInterpolateMethod);
	get label(): string | null;
	set label(value: string | null);
	get matteColor(): IMagickColor;
	set matteColor(value: IMagickColor);
	get metaChannelCount(): number;
	set metaChannelCount(value: number);
	get orientation(): Orientation;
	set orientation(value: Orientation);
	get onProgress(): ((event: ProgressEvent$1) => number) | undefined;
	set onProgress(value: ((event: ProgressEvent$1) => number) | undefined);
	get onWarning(): ((event: WarningEvent) => number) | undefined;
	set onWarning(value: ((event: WarningEvent) => number) | undefined);
	get page(): IMagickGeometry;
	set page(value: IMagickGeometry);
	get profileNames(): ReadonlyArray<string>;
	get quality(): number;
	set quality(value: number);
	get renderingIntent(): RenderingIntent;
	set renderingIntent(value: RenderingIntent);
	get settings(): MagickSettings;
	get signature(): string | null;
	get totalColors(): number;
	get virtualPixelMethod(): VirtualPixelMethod;
	set virtualPixelMethod(value: VirtualPixelMethod);
	get width(): number;
	adaptiveBlur(): void;
	adaptiveBlur(radius: number): void;
	adaptiveBlur(radius: number, sigma: number): void;
	adaptiveResize(geometry: IMagickGeometry): void;
	adaptiveResize(width: number, height: number): void;
	adaptiveSharpen(): void;
	adaptiveSharpen(channels: Channels): void;
	adaptiveSharpen(radius: number, sigma: number): void;
	adaptiveSharpen(radius: number, sigma: number, channels: Channels): void;
	adaptiveThreshold(width: number, height: number): void;
	adaptiveThreshold(width: number, height: number, channels: Channels): void;
	adaptiveThreshold(width: number, height: number, bias: Percentage): void;
	adaptiveThreshold(width: number, height: number, bias: Percentage, channels: Channels): void;
	addNoise(noiseType: NoiseType): void;
	addNoise(noiseType: NoiseType, channels: Channels): void;
	addNoise(noiseType: NoiseType, attenuate: number): void;
	addNoise(noiseType: NoiseType, attenuate: number, channels: Channels): void;
	alpha(value: AlphaAction): void;
	annotate(text: string, boundingArea: MagickGeometry): void;
	annotate(text: string, boundingArea: MagickGeometry, gravity: Gravity): void;
	annotate(text: string, boundingArea: MagickGeometry, gravity: Gravity, angle: number): void;
	annotate(text: string, gravity: Gravity): void;
	annotate(text: string, gravity: Gravity, angle: number): void;
	autoGamma(): void;
	autoLevel(): void;
	autoOrient(): void;
	autoThreshold(method: AutoThresholdMethod): void;
	bilateralBlur(width: number, height: number): void;
	bilateralBlur(width: number, height: number, intensitySigma: number, spatialSigma: number): void;
	blackThreshold(threshold: Percentage): void;
	blackThreshold(threshold: Percentage, channels: Channels): void;
	blueShift(): void;
	blueShift(factor: number): void;
	blur(): void;
	blur(channels: Channels): void;
	blur(radius: number, sigma: number): void;
	blur(radius: number, sigma: number, channels: Channels): void;
	border(size: number): void;
	border(width: number, height: number): void;
	brightnessContrast(brightness: Percentage, contrast: Percentage): void;
	brightnessContrast(brightness: Percentage, contrast: Percentage, channels: Channels): void;
	cannyEdge(): void;
	cannyEdge(radius: number, sigma: number, lower: Percentage, upper: Percentage): void;
	charcoal(): void;
	charcoal(radius: number, sigma: number): void;
	chop(geometry: MagickGeometry): void;
	chopHorizontal(x: number, width: number): void;
	chopVertical(y: number, height: number): void;
	clahe(xTiles: number, yTiles: number, numberBins: number, clipLimit: number): void;
	clahe(xTiles: Percentage, yTiles: Percentage, numberBins: number, clipLimit: number): void;
	clone<TReturnType>(func: SyncImageCallback<TReturnType>): TReturnType;
	clone<TReturnType>(func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	cloneArea<TReturnType>(geometry: MagickGeometry, func: SyncImageCallback<TReturnType>): TReturnType;
	cloneArea<TReturnType>(geometry: MagickGeometry, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	colorAlpha(color: IMagickColor): void;
	compare(image: IMagickImage, metric: ErrorMetric): number;
	compare(image: IMagickImage, metric: ErrorMetric, channels: Channels): number;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, channels: Channels, func: (compareResult: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, settings: CompareSettings, channels: Channels, func: (compareResult: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, func: (image: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, func: (image: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, channels: Channels, func: (result: CompareResult) => TReturnType): TReturnType;
	compare<TReturnType>(image: IMagickImage, metric: ErrorMetric, channels: Channels, func: (result: CompareResult) => Promise<TReturnType>): Promise<TReturnType>;
	composite(image: IMagickImage): void;
	composite(image: IMagickImage, compose: CompositeOperator): void;
	composite(image: IMagickImage, compose: CompositeOperator, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, args: string): void;
	composite(image: IMagickImage, compose: CompositeOperator, args: string, channels: Channels): void;
	composite(image: IMagickImage, point: Point): void;
	composite(image: IMagickImage, point: Point, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, channels: Channels): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, args: string): void;
	composite(image: IMagickImage, compose: CompositeOperator, point: Point, args: string, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, args: string): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, args: string, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, point: Point): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, point: Point, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, channels: Channels): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, args: string): void;
	compositeGravity(image: IMagickImage, gravity: Gravity, compose: CompositeOperator, point: Point, args: string, channels: Channels): void;
	connectedComponents(connectivity: Connectivity): ConnectedComponent[];
	connectedComponents(settings: ConnectedComponentsSettings): ConnectedComponent[];
	contrast: () => void;
	contrastStretch(blackPoint: Percentage): void;
	contrastStretch(blackPoint: Percentage, channnels: Channels): void;
	contrastStretch(blackPoint: Percentage, whitePoint: Percentage): void;
	contrastStretch(blackPoint: Percentage, whitePoint: Percentage, channnels: Channels): void;
	static create(): IMagickImage;
	static create(color: IMagickColor, width: number, height: number): IMagickImage;
	static create(fileName: string, settings?: MagickReadSettings): IMagickImage;
	static create(array: ByteArray, settings?: MagickReadSettings): IMagickImage;
	crop(geometry: IMagickGeometry): void;
	crop(geometry: IMagickGeometry, gravity: Gravity): void;
	crop(width: number, height: number): void;
	crop(width: number, height: number, gravity: Gravity): void;
	cropToTiles<TReturnType>(geometry: IMagickGeometry, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	cropToTiles<TReturnType>(geometry: IMagickGeometry, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	cropToTiles<TReturnType>(width: number, height: number, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	cropToTiles<TReturnType>(width: number, height: number, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	deskew(threshold: Percentage): number;
	deskew(threshold: Percentage, autoCrop: boolean): number;
	distort(method: DistortMethod, params: number[]): void;
	distort(settings: DistortSettings, params: number[]): void;
	draw(drawables: IDrawable[]): void;
	draw(...drawables: IDrawable[]): void;
	evaluate(channels: Channels, operator: EvaluateOperator, value: number): void;
	evaluate(channels: Channels, operator: EvaluateOperator, value: Percentage): void;
	evaluate(channels: Channels, geometry: IMagickGeometry, operator: EvaluateOperator, value: number): void;
	evaluate(channels: Channels, geometry: IMagickGeometry, operator: EvaluateOperator, value: Percentage): void;
	extent(width: number, height: number): void;
	extent(width: number, height: number, gravity: Gravity): void;
	extent(width: number, height: number, backgroundColor: IMagickColor): void;
	extent(geometry: IMagickGeometry): void;
	extent(geometry: IMagickGeometry, gravity: Gravity): void;
	extent(geometry: IMagickGeometry, gravity: Gravity, backgroundColor: IMagickColor): void;
	extent(geometry: IMagickGeometry, backgroundColor: IMagickColor): void;
	flip(): void;
	flop(): void;
	formatExpression(expression: string): string | null;
	gammaCorrect(gamma: number): void;
	gammaCorrect(gamma: number, channels: Channels): void;
	gaussianBlur(radius: number): void;
	gaussianBlur(radius: number, sigma: number): void;
	gaussianBlur(radius: number, sigma: number, channels: Channels): void;
	getArtifact(name: string): string | null;
	getAttribute(name: string): string | null;
	getColorProfile(): IColorProfile | null;
	getPixels<TReturnType>(func: (pixels: IPixelCollection) => TReturnType): TReturnType;
	getPixels<TReturnType>(func: (pixels: IPixelCollection) => Promise<TReturnType>): Promise<TReturnType>;
	getProfile(name: string): IImageProfile | null;
	getWriteMask<TReturnType>(func: (mask: IMagickImage | null) => TReturnType): TReturnType;
	getWriteMask<TReturnType>(func: (mask: IMagickImage | null) => Promise<TReturnType>): Promise<TReturnType>;
	grayscale(method?: PixelIntensityMethod): void;
	hasProfile(name: string): boolean;
	histogram(): Map<string, number>;
	inverseContrast: () => void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage): void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage, gamma: number): void;
	inverseLevel(blackPoint: Percentage, whitePoint: Percentage, gamma: number, channels: Channels): void;
	inverseOpaque: (target: IMagickColor, fill: IMagickColor) => void;
	inverseSigmoidalContrast(contrast: number): void;
	inverseSigmoidalContrast(contrast: number, midpoint: Percentage): void;
	inverseSigmoidalContrast(contrast: number, midpoint: number): void;
	inverseSigmoidalContrast(contrast: number, midpoint: number, channels: Channels): void;
	inverseTransparent: (color: IMagickColor) => void;
	level(blackPoint: Percentage, whitePoint: Percentage): void;
	level(blackPoint: Percentage, whitePoint: Percentage, gamma: number): void;
	level(blackPoint: Percentage, whitePoint: Percentage, gamma: number, channels: Channels): void;
	linearStretch(blackPoint: Percentage, whitePoint: Percentage): void;
	liquidRescale(geometry: IMagickGeometry): void;
	liquidRescale(width: number, height: number): void;
	negate(): void;
	negateGrayScale(): void;
	normalize(): void;
	modulate(brightness: Percentage): void;
	modulate(brightness: Percentage, saturation: Percentage): void;
	modulate(brightness: Percentage, saturation: Percentage, hue: Percentage): void;
	morphology(settings: MorphologySettings): void;
	motionBlur(radius: number, sigma: number, angle: number): void;
	oilPaint(): void;
	oilPaint(radius: number): void;
	opaque: (target: IMagickColor, fill: IMagickColor) => void;
	ping(fileName: string, settings?: MagickReadSettings): void;
	ping(array: ByteArray, settings?: MagickReadSettings): void;
	perceptualHash(): IPerceptualHash;
	perceptualHash(colorSpaces: ReadonlyArray<ColorSpace>): IPerceptualHash;
	quantize(settingsOrUndefined?: QuantizeSettings): MagickErrorInfo | null;
	read(color: IMagickColor, width: number, height: number): void;
	read(fileName: string, settings?: MagickReadSettings): void;
	read(array: ByteArray, settings?: MagickReadSettings): void;
	readFromCanvas(canvas: HTMLCanvasElement, settings?: CanvasRenderingContext2DSettings): void;
	removeArtifact(name: string): void;
	removeAttribute(name: string): void;
	removeProfile(profile: IImageProfile): void;
	removeProfile(name: string): void;
	removeWriteMask(): void;
	resetPage(): void;
	resize(geometry: IMagickGeometry): void;
	resize(width: number, height: number): void;
	rotate(degrees: number): void;
	separate<TReturnType>(func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	separate<TReturnType>(func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	separate<TReturnType>(channels: Channels, func: (images: IMagickImageCollection) => TReturnType): TReturnType;
	separate<TReturnType>(channels: Channels, func: (images: IMagickImageCollection) => Promise<TReturnType>): Promise<TReturnType>;
	sepiaTone(): void;
	setArtifact(name: string, value: boolean | IMagickColor | number | string): void;
	setAttribute(name: string, value: string): void;
	setProfile(profile: IImageProfile): void;
	setProfile(pname: string, data: ByteArray): void;
	setWriteMask(image: IMagickImage): void;
	sharpen(): void;
	sharpen(radius: number, sigma: number): void;
	sharpen(radius: number, sigma: number, channels: Channels): void;
	shave(leftRight: number, topBottom: number): void;
	sigmoidalContrast(contrast: number): void;
	sigmoidalContrast(contrast: number, midpoint: Percentage): void;
	sigmoidalContrast(contrast: number, midpoint: number): void;
	sigmoidalContrast(contrast: number, midpoint: number, channels: Channels): void;
	solarize(): void;
	splice(geometry: IMagickGeometry): void;
	statistics(): IStatistics;
	statistics(channels: Channels): IStatistics;
	strip(): void;
	transformColorSpace(target: IColorProfile): boolean;
	transformColorSpace(target: IColorProfile, mode: ColorTransformMode): boolean;
	transformColorSpace(source: IColorProfile, target: IColorProfile): boolean;
	transformColorSpace(source: IColorProfile, target: IColorProfile, mode: ColorTransformMode): boolean;
	threshold(percentage: Percentage): void;
	threshold(percentage: Percentage, channels: Channels): void;
	thumbnail(width: number, height: number): void;
	thumbnail(geometry: IMagickGeometry): void;
	toString: () => string;
	transparent(color: IMagickColor): void;
	trim(): void;
	trim(...edges: Gravity[]): void;
	trim(percentage: Percentage): void;
	wave(): void;
	wave(method: PixelInterpolateMethod, amplitude: number, length: number): void;
	vignette(): void;
	vignette(radius: number, sigma: number, x: number, y: number): void;
	whiteThreshold(threshold: Percentage): void;
	whiteThreshold(threshold: Percentage, channels: Channels): void;
	write<TReturnType>(func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => TReturnType): TReturnType;
	write<TReturnType>(format: MagickFormat, func: (data: Uint8Array) => Promise<TReturnType>): Promise<TReturnType>;
	writeToCanvas(canvas: HTMLCanvasElement, settings?: CanvasRenderingContext2DSettings): void;
	protected onDispose(): void;
	private _contrast;
	private _getProfile;
	private _opaque;
	private _sigmoidalContrast;
	private _transparent;
	private static createInstance;
	private fromBool;
	private disposeProgressDelegate;
	private readOrPing;
	private readFromArray;
	private toBool;
	private valueOrDefault;
	private valueOrComputedDefault;
	private useException;
	private useExceptionPointer;
}
export declare class TypeMetric {
	private constructor();
	readonly ascent: number;
	readonly descent: number;
	readonly maxHorizontalAdvance: number;
	readonly textHeight: number;
	readonly textWidth: number;
	readonly underlinePosition: number;
	readonly underlineThickness: number;
}
export declare class Drawables {
	private _drawables;
	disableStrokeAntialias(): Drawables;
	enableStrokeAntialias(): Drawables;
	fillColor(color: IMagickColor): Drawables;
	fillOpacity(opacity: Percentage): Drawables;
	font(font: string): Drawables;
	fontPointSize(pointSize: number): Drawables;
	fontTypeMetrics(text: string, ignoreNewlines?: boolean): TypeMetric | null;
	gravity(value: Gravity): Drawables;
	line(startX: number, startY: number, endX: number, endY: number): Drawables;
	point(x: number, y: number): Drawables;
	rectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number): Drawables;
	roundRectangle(upperLeftX: number, upperLeftY: number, lowerRightX: number, lowerRightY: number, cornerWidth: number, cornerHeight: number): Drawables;
	strokeColor(color: IMagickColor): Drawables;
	strokeWidth(width: number): Drawables;
	text(x: number, y: number, value: string): Drawables;
	textAlignment(alignment: TextAlignment): Drawables;
	textDecoration(decoration: TextDecoration): Drawables;
	textInterlineSpacing(spacing: number): Drawables;
	textInterwordSpacing(spacing: number): Drawables;
	textKerning(kerning: number): Drawables;
	textUnderColor(color: IMagickColor): Drawables;
	draw(image: IMagickImage): Drawables;
}
export declare const LogEventTypes: {
	readonly None: 0;
	readonly Accelerate: 1;
	readonly Annotate: 2;
	readonly Blob: 4;
	readonly Cache: 8;
	readonly Coder: 16;
	readonly Configure: 32;
	readonly Deprecate: 64;
	readonly Draw: 128;
	readonly Exception: 256;
	readonly Image: 512;
	readonly Locale: 1024;
	readonly Module: 2048;
	readonly Pixel: 4096;
	readonly Policy: 8192;
	readonly Resource: 16384;
	readonly Trace: 32768;
	readonly Transform: 65536;
	readonly User: 131072;
	readonly Wand: 262144;
	readonly Detailed: 2147450879;
	readonly All: number;
};
export type LogEventTypes = typeof LogEventTypes[keyof typeof LogEventTypes];
export declare class LogEvent {
	constructor(eventType: LogEventTypes, message?: string);
	readonly eventType: LogEventTypes;
	readonly message: string;
}
export declare enum DngInterpolation {
	Disabled = -1,
	Linear = 0,
	Vng = 1,
	Ppg = 2,
	Ahd = 3,
	DCB = 4,
	Dht = 11,
	ModifiedAhd = 12
}
export declare enum DngOutputColor {
	Raw = 0,
	SRGB = 1,
	AdobeRGB = 2,
	WideGamutRGB = 3,
	KodakProPhotoRGB = 4,
	XYZ = 5,
	ACES = 6
}
export declare class DngReadDefines extends DefinesCreator {
	constructor();
	disableAutoBrightness?: boolean;
	interpolationQuality?: DngInterpolation;
	outputColor?: DngOutputColor;
	useAutoWhitebalance?: boolean;
	useCameraWhitebalance?: boolean;
	getDefines(): IDefine[];
}
export declare class ImageMagick {
	private readonly loader;
	private api?;
	static read<TReturnType>(color: IMagickColor, width: number, height: number, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(color: IMagickColor, width: number, height: number, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(array: ByteArray, format: MagickFormat, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(array: ByteArray, format: MagickFormat, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(array: ByteArray, settings: MagickReadSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(array: ByteArray, settings: MagickReadSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(array: ByteArray, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(array: ByteArray, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(fileName: string, format: MagickFormat, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(fileName: string, format: MagickFormat, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(fileName: string, settings: MagickReadSettings, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(fileName: string, settings: MagickReadSettings, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static read<TReturnType>(fileName: string, func: SyncImageCallback<TReturnType>): TReturnType;
	static read<TReturnType>(fileName: string, func: AsyncImageCallback<TReturnType>): Promise<TReturnType>;
	static readCollection<TReturnType>(array: ByteArray, format: MagickFormat, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	static readCollection<TReturnType>(array: ByteArray, format: MagickFormat, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	static readCollection<TReturnType>(array: ByteArray, settings: MagickReadSettings, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	static readCollection<TReturnType>(array: ByteArray, settings: MagickReadSettings, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	static readCollection<TReturnType>(array: ByteArray, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	static readCollection<TReturnType>(array: ByteArray, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	static readCollection<TReturnType>(fileName: string, settings: MagickReadSettings, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	static readCollection<TReturnType>(fileName: string, settings: MagickReadSettings, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	static readCollection<TReturnType>(fileName: string, func: SyncImageCollectionCallback<TReturnType>): TReturnType;
	static readCollection<TReturnType>(fileName: string, func: AsyncImageCollectionCallback<TReturnType>): Promise<TReturnType>;
	static readFromCanvas<TReturnType>(canvas: HTMLCanvasElement, func: SyncImageCallback<TReturnType>, settings?: CanvasRenderingContext2DSettings): TReturnType;
	static readFromCanvas<TReturnType>(canvas: HTMLCanvasElement, func: AsyncImageCallback<TReturnType>, settings?: CanvasRenderingContext2DSettings): Promise<TReturnType>;
	private writeConfigurationFiles;
}
export declare function initializeImageMagick(wasmLocationDataOrAssembly: URL | ByteArray | WebAssembly.Module, configurationFiles?: IConfigurationFiles): Promise<void>;
export declare class MagickColors {
	static get None(): IMagickColor;
	static get Transparent(): IMagickColor;
	static get AliceBlue(): IMagickColor;
	static get AntiqueWhite(): IMagickColor;
	static get Aqua(): IMagickColor;
	static get Aquamarine(): IMagickColor;
	static get Azure(): IMagickColor;
	static get Beige(): IMagickColor;
	static get Bisque(): IMagickColor;
	static get Black(): IMagickColor;
	static get BlanchedAlmond(): IMagickColor;
	static get Blue(): IMagickColor;
	static get BlueViolet(): IMagickColor;
	static get Brown(): IMagickColor;
	static get BurlyWood(): IMagickColor;
	static get CadetBlue(): IMagickColor;
	static get Chartreuse(): IMagickColor;
	static get Chocolate(): IMagickColor;
	static get Coral(): IMagickColor;
	static get CornflowerBlue(): IMagickColor;
	static get Cornsilk(): IMagickColor;
	static get Crimson(): IMagickColor;
	static get Cyan(): IMagickColor;
	static get DarkBlue(): IMagickColor;
	static get DarkCyan(): IMagickColor;
	static get DarkGoldenrod(): IMagickColor;
	static get DarkGray(): IMagickColor;
	static get DarkGreen(): IMagickColor;
	static get DarkKhaki(): IMagickColor;
	static get DarkMagenta(): IMagickColor;
	static get DarkOliveGreen(): IMagickColor;
	static get DarkOrange(): IMagickColor;
	static get DarkOrchid(): IMagickColor;
	static get DarkRed(): IMagickColor;
	static get DarkSalmon(): IMagickColor;
	static get DarkSeaGreen(): IMagickColor;
	static get DarkSlateBlue(): IMagickColor;
	static get DarkSlateGray(): IMagickColor;
	static get DarkTurquoise(): IMagickColor;
	static get DarkViolet(): IMagickColor;
	static get DeepPink(): IMagickColor;
	static get DeepSkyBlue(): IMagickColor;
	static get DimGray(): IMagickColor;
	static get DodgerBlue(): IMagickColor;
	static get Firebrick(): IMagickColor;
	static get FloralWhite(): IMagickColor;
	static get ForestGreen(): IMagickColor;
	static get Fuchsia(): IMagickColor;
	static get Gainsboro(): IMagickColor;
	static get GhostWhite(): IMagickColor;
	static get Gold(): IMagickColor;
	static get Goldenrod(): IMagickColor;
	static get Gray(): IMagickColor;
	static get Green(): IMagickColor;
	static get GreenYellow(): IMagickColor;
	static get Honeydew(): IMagickColor;
	static get HotPink(): IMagickColor;
	static get IndianRed(): IMagickColor;
	static get Indigo(): IMagickColor;
	static get Ivory(): IMagickColor;
	static get Khaki(): IMagickColor;
	static get Lavender(): IMagickColor;
	static get LavenderBlush(): IMagickColor;
	static get LawnGreen(): IMagickColor;
	static get LemonChiffon(): IMagickColor;
	static get LightBlue(): IMagickColor;
	static get LightCoral(): IMagickColor;
	static get LightCyan(): IMagickColor;
	static get LightGoldenrodYellow(): IMagickColor;
	static get LightGreen(): IMagickColor;
	static get LightGray(): IMagickColor;
	static get LightPink(): IMagickColor;
	static get LightSalmon(): IMagickColor;
	static get LightSeaGreen(): IMagickColor;
	static get LightSkyBlue(): IMagickColor;
	static get LightSlateGray(): IMagickColor;
	static get LightSteelBlue(): IMagickColor;
	static get LightYellow(): IMagickColor;
	static get Lime(): IMagickColor;
	static get LimeGreen(): IMagickColor;
	static get Linen(): IMagickColor;
	static get Magenta(): IMagickColor;
	static get Maroon(): IMagickColor;
	static get MediumAquamarine(): IMagickColor;
	static get MediumBlue(): IMagickColor;
	static get MediumOrchid(): IMagickColor;
	static get MediumPurple(): IMagickColor;
	static get MediumSeaGreen(): IMagickColor;
	static get MediumSlateBlue(): IMagickColor;
	static get MediumSpringGreen(): IMagickColor;
	static get MediumTurquoise(): IMagickColor;
	static get MediumVioletRed(): IMagickColor;
	static get MidnightBlue(): IMagickColor;
	static get MintCream(): IMagickColor;
	static get MistyRose(): IMagickColor;
	static get Moccasin(): IMagickColor;
	static get NavajoWhite(): IMagickColor;
	static get Navy(): IMagickColor;
	static get OldLace(): IMagickColor;
	static get Olive(): IMagickColor;
	static get OliveDrab(): IMagickColor;
	static get Orange(): IMagickColor;
	static get OrangeRed(): IMagickColor;
	static get Orchid(): IMagickColor;
	static get PaleGoldenrod(): IMagickColor;
	static get PaleGreen(): IMagickColor;
	static get PaleTurquoise(): IMagickColor;
	static get PaleVioletRed(): IMagickColor;
	static get PapayaWhip(): IMagickColor;
	static get PeachPuff(): IMagickColor;
	static get Peru(): IMagickColor;
	static get Pink(): IMagickColor;
	static get Plum(): IMagickColor;
	static get PowderBlue(): IMagickColor;
	static get Purple(): IMagickColor;
	static get RebeccaPurple(): IMagickColor;
	static get Red(): IMagickColor;
	static get RosyBrown(): IMagickColor;
	static get RoyalBlue(): IMagickColor;
	static get SaddleBrown(): IMagickColor;
	static get Salmon(): IMagickColor;
	static get SandyBrown(): IMagickColor;
	static get SeaGreen(): IMagickColor;
	static get SeaShell(): IMagickColor;
	static get Sienna(): IMagickColor;
	static get Silver(): IMagickColor;
	static get SkyBlue(): IMagickColor;
	static get SlateBlue(): IMagickColor;
	static get SlateGray(): IMagickColor;
	static get Snow(): IMagickColor;
	static get SpringGreen(): IMagickColor;
	static get SteelBlue(): IMagickColor;
	static get Tan(): IMagickColor;
	static get Teal(): IMagickColor;
	static get Thistle(): IMagickColor;
	static get Tomato(): IMagickColor;
	static get Turquoise(): IMagickColor;
	static get Violet(): IMagickColor;
	static get Wheat(): IMagickColor;
	static get White(): IMagickColor;
	static get WhiteSmoke(): IMagickColor;
	static get Yellow(): IMagickColor;
	static get YellowGreen(): IMagickColor;
}
export interface IMagickFormatInfo {
	readonly description: string;
	readonly format: MagickFormat;
	readonly supportsMultipleFrames: boolean;
	readonly supportsReading: boolean;
	readonly supportsWriting: boolean;
}
export interface IMagickImageInfo {
	readonly colorSpace: ColorSpace;
	readonly compression: CompressionMethod;
	readonly density: Density;
	readonly format: MagickFormat;
	readonly height: number;
	readonly interlace: Interlace;
	readonly orientation: Orientation;
	readonly quality: number;
	readonly width: number;
	read(array: ByteArray, settings?: MagickReadSettings): void;
}
export declare class MagickImageInfo implements IMagickImageInfo {
	private _colorSpace;
	private _compression;
	private _density;
	private _format;
	private _height;
	private _interlace;
	private _orientation;
	private _quality;
	private _width;
	get colorSpace(): ColorSpace;
	get compression(): CompressionMethod;
	get density(): Density;
	get format(): MagickFormat;
	get height(): number;
	get interlace(): Interlace;
	get orientation(): Orientation;
	get quality(): number;
	get width(): number;
	constructor();
	read(array: ByteArray, settings?: MagickReadSettings): void;
	static create(array: ByteArray, settings?: MagickReadSettings): IMagickImageInfo;
}
export declare class Magick {
	static get delegates(): string;
	static get features(): string;
	static get imageMagickVersion(): string;
	static get supportedFormats(): ReadonlyArray<IMagickFormatInfo>;
	static onLog?: (event: LogEvent) => void;
	static addFont(name: string, data: Uint8Array): void;
	static resetRandomSeed: () => void;
	static setRandomSeed: (seed: number) => void;
	static setLogEvents(eventTypes: LogEventTypes): void;
	private static getEventTypeString;
	private static logDelegate;
}
export declare class Quantum {
	static get depth(): number;
	static get max(): number;
}
export declare class OffsetInfo {
	static _use<TReturnType>(x: number, y: number, func: (primaryInfoPtr: number) => TReturnType | Promise<TReturnType>): TReturnType | Promise<TReturnType>;
}

export {
	ProgressEvent$1 as ProgressEvent,
};

export {};
