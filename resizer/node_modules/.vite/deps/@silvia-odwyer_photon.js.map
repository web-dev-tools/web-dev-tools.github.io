{
  "version": 3,
  "sources": ["../../@silvia-odwyer/photon/photon_rs.js"],
  "sourcesContent": ["let wasm;\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n * Alter a select channel by incrementing or decrementing its value by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel` - The channel you wish to alter, it should be either 0, 1 or 2,\n * representing R, G, or B respectively. (O=Red, 1=Green, 2=Blue)\n * * `amount` - The amount to increment/decrement the channel's value by for that pixel.\n * A positive value will increment/decrement the channel's value, a negative value will decrement the channel's value.\n *\n * ## Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::channels::alter_channel;\n * use photon_rs::native::{open_image};\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channel(&mut img, 0_usize, 10_i16);\n * ```\n *\n * Adds a constant to a select R, G, or B channel's value.\n *\n * ### Decrease a channel's value\n * // For example, to decrease the Green channel for all pixels by 20:\n * ```no_run\n * use photon_rs::channels::alter_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channel(&mut img, 1_usize, -20_i16);\n * ```\n * **Note**: Note the use of a minus symbol when decreasing the channel.\n * @param {PhotonImage} img\n * @param {number} channel\n * @param {number} amt\n */\nexport function alter_channel(img, channel, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channel(img.__wbg_ptr, channel, amt);\n}\n\n/**\n * Increment or decrement every pixel's Red channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::channels::alter_red_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_red_channel(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} amt\n */\nexport function alter_red_channel(photon_image, amt) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.alter_red_channel(photon_image.__wbg_ptr, amt);\n}\n\n/**\n * Increment or decrement every pixel's Green channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `amt` - The amount to increment/decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Green channel for all pixels by 20:\n * use photon_rs::channels::alter_green_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_green_channel(&mut img, 20_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} amt\n */\nexport function alter_green_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_green_channel(img.__wbg_ptr, amt);\n}\n\n/**\n * Increment or decrement every pixel's Blue channel by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `amt` - The amount to increment or decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Blue channel for all pixels by 10:\n * use photon_rs::channels::alter_blue_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_blue_channel(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} amt\n */\nexport function alter_blue_channel(img, amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_blue_channel(img.__wbg_ptr, amt);\n}\n\n/**\n * Increment/decrement two channels' values simultaneously by adding an amt to each channel per pixel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel1` - A usize from 0 to 2 that represents either the R, G or B channels.\n * * `amt1` - The amount to increment/decrement the channel's value by for that pixel.\n * * `channel2` -A usize from 0 to 2 that represents either the R, G or B channels.\n * * `amt2` - The amount to increment/decrement the channel's value by for that pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the values of the Red and Blue channels per pixel:\n * use photon_rs::channels::alter_two_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_two_channels(&mut img, 0_usize, 10_i16, 2_usize, 20_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel1\n * @param {number} amt1\n * @param {number} channel2\n * @param {number} amt2\n */\nexport function alter_two_channels(img, channel1, amt1, channel2, amt2) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_two_channels(img.__wbg_ptr, channel1, amt1, channel2, amt2);\n}\n\n/**\n * Increment all 3 channels' values by adding an amt to each channel per pixel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `r_amt` - The amount to increment/decrement the Red channel by.\n * * `g_amt` - The amount to increment/decrement the Green channel by.\n * * `b_amt` - The amount to increment/decrement the Blue channel by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the values of the Red channel by 10, the Green channel by 20,\n * // and the Blue channel by 50:\n * use photon_rs::channels::alter_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * alter_channels(&mut img, 10_i16, 20_i16, 50_i16);\n * ```\n * @param {PhotonImage} img\n * @param {number} r_amt\n * @param {number} g_amt\n * @param {number} b_amt\n */\nexport function alter_channels(img, r_amt, g_amt, b_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.alter_channels(img.__wbg_ptr, r_amt, g_amt, b_amt);\n}\n\n/**\n * Set a certain channel to zero, thus removing the channel's influence in the pixels' final rendered colour.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel` - The channel to be removed; must be a usize from 0 to 2, with 0 representing Red, 1 representing Green, and 2 representing Blue.\n * * `min_filter` - Minimum filter. Value between 0 and 255. Only remove the channel if the current pixel's channel value is less than this minimum filter. To completely\n * remove the channel, set this value to 255, to leave the channel as is, set to 0, and to set a channel to zero for a pixel whose red value is greater than 50,\n * then channel would be 0 and min_filter would be 50.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the Red channel with a min_filter of 100:\n * use photon_rs::channels::remove_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_channel(&mut img, 0_usize, 100_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel\n * @param {number} min_filter\n */\nexport function remove_channel(img, channel, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_channel(img.__wbg_ptr, channel, min_filter);\n}\n\n/**\n * Remove the Red channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the red channel for red channel pixel values less than 50:\n * use photon_rs::channels::remove_red_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_red_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_red_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_red_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Remove the Green channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the green channel for green channel pixel values less than 50:\n * use photon_rs::channels::remove_green_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_green_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_green_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_green_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Remove the Blue channel's influence in an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `min_filter` - Only remove the channel if the current pixel's channel value is less than this minimum filter.\n *\n * # Example\n *\n * ```no_run\n * // For example, to remove the blue channel for blue channel pixel values less than 50:\n * use photon_rs::channels::remove_blue_channel;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * remove_blue_channel(&mut img, 50_u8);\n * ```\n * @param {PhotonImage} img\n * @param {number} min_filter\n */\nexport function remove_blue_channel(img, min_filter) {\n    _assertClass(img, PhotonImage);\n    wasm.remove_blue_channel(img.__wbg_ptr, min_filter);\n}\n\n/**\n * Swap two channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `channel1` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Red would be represented by 0, Green by 1, and Blue by 2.\n * * `channel2` - An index from 0 to 2, representing the Red, Green or Blue channels respectively. Same as above.\n *\n * # Example\n *\n * ```no_run\n * // For example, to swap the values of the Red channel with the values of the Blue channel:\n * use photon_rs::channels::swap_channels;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * swap_channels(&mut img, 0_usize, 2_usize);\n * ```\n * @param {PhotonImage} img\n * @param {number} channel1\n * @param {number} channel2\n */\nexport function swap_channels(img, channel1, channel2) {\n    _assertClass(img, PhotonImage);\n    wasm.swap_channels(img.__wbg_ptr, channel1, channel2);\n}\n\n/**\n * Invert RGB value of an image.\n *\n * # Arguments\n * * `photon_image` - A DynamicImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * use photon_rs::channels::invert;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * invert(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function invert(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.invert(photon_image.__wbg_ptr);\n}\n\n/**\n * Selective hue rotation.\n *\n * Only rotate the hue of a pixel if its RGB values are within a specified range.\n * This function only rotates a pixel's hue to another  if it is visually similar to the colour specified.\n * For example, if a user wishes all pixels that are blue to be changed to red, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `degrees` - The amount of degrees to hue rotate by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only rotate the pixels that are of RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_hue_rotate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_hue_rotate(&mut img, ref_color, 180_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n * @param {number} degrees\n */\nexport function selective_hue_rotate(photon_image, ref_color, degrees) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_hue_rotate(photon_image.__wbg_ptr, ptr0, degrees);\n}\n\n/**\n * Selectively change pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only changes the color of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, with this function, a user can change the color of all blue pixels by mixing them with red by 10%.\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `new_color` - The `RGB` value of the new color (to be mixed with the matched pixels)\n * * `fraction` - The amount of mixing the new colour with the matched pixels\n *\n * # Example\n *\n * ```no_run\n * // For example, to only change the color of pixels that are similar to the RGB value RGB{200, 120, 30} by mixing RGB{30, 120, 200} with 25%:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_color_convert;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(200, 120, 30);\n * let new_color = Rgb::new(30, 120, 200);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_color_convert(&mut img, ref_color, new_color, 0.25);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n * @param {Rgb} new_color\n * @param {number} fraction\n */\nexport function selective_color_convert(photon_image, ref_color, new_color, fraction) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    _assertClass(new_color, Rgb);\n    var ptr1 = new_color.__destroy_into_raw();\n    wasm.selective_color_convert(photon_image.__wbg_ptr, ptr0, ptr1, fraction);\n}\n\n/**\n * Selectively lighten an image.\n *\n * Only lighten the hue of a pixel if its colour matches or is similar to the RGB colour specified.\n * For example, if a user wishes all pixels that are blue to be lightened, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The level from 0 to 1 to lighten the hue by. Increasing by 10% would have an `amt` of 0.1\n *\n * # Example\n *\n * ```no_run\n * // For example, to only lighten the pixels that are of or similar to RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_lighten;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_lighten(&mut img, ref_color, 0.2_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_lighten(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_lighten(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively desaturate pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only desaturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, if a user wishes all pixels that are blue to be desaturated by 0.1, they can selectively specify  only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The amount of desaturate the colour by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only desaturate the pixels that are similar to the RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_desaturate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_desaturate(&mut img, ref_color, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_desaturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_desaturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively saturate pixel colours which are similar to the reference colour provided.\n *\n * Similarity between two colours is calculated via the CIE76 formula.\n * Only saturates the hue of a pixel if its similarity to the reference colour is within the range in the algorithm.\n * For example, if a user wishes all pixels that are blue to have an increase in saturation by 10%, they can selectively specify only the blue pixels to be changed.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n * * `amt` - The amount of saturate the colour by.\n *\n * # Example\n *\n * ```no_run\n * // For example, to only increase the saturation of pixels that are similar to the RGB value RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_saturate;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_saturate(&mut img, ref_color, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} ref_color\n * @param {number} amt\n */\nexport function selective_saturate(img, ref_color, amt) {\n    _assertClass(img, PhotonImage);\n    _assertClass(ref_color, Rgb);\n    var ptr0 = ref_color.__destroy_into_raw();\n    wasm.selective_saturate(img.__wbg_ptr, ptr0, amt);\n}\n\n/**\n * Selectively changes a pixel to greyscale if it is *not* visually similar or close to the colour specified.\n * Only changes the colour of a pixel if its RGB values are within a specified range.\n *\n * (Similarity between two colours is calculated via the CIE76 formula.)\n * For example, if a user wishes all pixels that are *NOT* blue to be displayed in greyscale, they can selectively specify only the blue pixels to be\n * kept in the photo.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `ref_color` - The `RGB` value of the reference color (to be compared to)\n *\n * # Example\n *\n * ```no_run\n * // For example, to greyscale all pixels that are *not* visually similar to the RGB colour RGB{20, 40, 60}:\n * use photon_rs::Rgb;\n * use photon_rs::channels::selective_greyscale;\n * use photon_rs::native::open_image;\n *\n * let ref_color = Rgb::new(20_u8, 40_u8, 60_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * selective_greyscale(img, ref_color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} ref_color\n */\nexport function selective_greyscale(photon_image, ref_color) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.__destroy_into_raw();\n    _assertClass(ref_color, Rgb);\n    var ptr1 = ref_color.__destroy_into_raw();\n    wasm.selective_greyscale(ptr0, ptr1);\n}\n\n/**\n * Apply a monochrome effect of a certain colour.\n *\n * It does so by averaging the R, G, and B values of a pixel, and then adding a\n * separate value to that averaged value for each channel to produce a tint.\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `r_offset` - The value to add to the Red channel per pixel.\n * * `g_offset` - The value to add to the Green channel per pixel.\n * * `b_offset` - The value to add to the Blue channel per pixel.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a monochrome effect to an image:\n * use photon_rs::monochrome::monochrome;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * monochrome(&mut img, 40_u32, 50_u32, 100_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} r_offset\n * @param {number} g_offset\n * @param {number} b_offset\n */\nexport function monochrome(img, r_offset, g_offset, b_offset) {\n    _assertClass(img, PhotonImage);\n    wasm.monochrome(img.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n * Convert an image to sepia.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to sepia an image of type `PhotonImage`:\n * use photon_rs::monochrome::sepia;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sepia(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function sepia(img) {\n    _assertClass(img, PhotonImage);\n    wasm.sepia(img.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale using the conventional averaging algorithm.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to convert an image of type `PhotonImage` to grayscale:\n * use photon_rs::monochrome::grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function grayscale(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale(img.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale with a human corrected factor, to account for human vision.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to convert an image of type `PhotonImage` to grayscale with a human corrected factor:\n * use photon_rs::monochrome::grayscale_human_corrected;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale_human_corrected(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function grayscale_human_corrected(img) {\n    _assertClass(img, PhotonImage);\n    wasm.grayscale_human_corrected(img.__wbg_ptr);\n}\n\n/**\n * Desaturate an image by getting the min/max of each pixel's RGB values.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * // For example, to desaturate an image:\n * use photon_rs::monochrome::desaturate;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function desaturate(img) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate(img.__wbg_ptr);\n}\n\n/**\n * Uses a min. decomposition algorithm to convert an image to greyscale.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to decompose an image with min decomposition:\n * use photon_rs::monochrome::decompose_min;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * decompose_min(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function decompose_min(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_min(img.__wbg_ptr);\n}\n\n/**\n * Uses a max. decomposition algorithm to convert an image to greyscale.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to decompose an image with max decomposition:\n * use photon_rs::monochrome::decompose_max;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * decompose_max(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function decompose_max(img) {\n    _assertClass(img, PhotonImage);\n    wasm.decompose_max(img.__wbg_ptr);\n}\n\n/**\n * Employ only a limited number of gray shades in an image.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `num_shades` - The number of grayscale shades to be displayed in the image.\n *\n * # Example\n *\n * ```no_run\n * // For example, to limit an image to four shades of gray only:\n * use photon_rs::monochrome::grayscale_shades;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * grayscale_shades(&mut img, 4_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_shades\n */\nexport function grayscale_shades(photon_image, num_shades) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.grayscale_shades(photon_image.__wbg_ptr, num_shades);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Red channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::r_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * r_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function r_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.r_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Green channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::g_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * g_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function g_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.g_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to the Blue channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * use photon_rs::monochrome::b_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * b_grayscale(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function b_grayscale(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.b_grayscale(photon_image.__wbg_ptr);\n}\n\n/**\n * Convert an image to grayscale by setting a pixel's 3 RGB values to a chosen channel's value.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `channel` - A usize representing the channel from 0 to 2. O represents the Red channel, 1 the Green channel, and 2 the Blue channel.\n *\n * # Example\n * To grayscale using only values from the Red channel:\n * ```no_run\n * use photon_rs::monochrome::single_channel_grayscale;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * single_channel_grayscale(&mut img, 0_usize);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} channel\n */\nexport function single_channel_grayscale(photon_image, channel) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.single_channel_grayscale(photon_image.__wbg_ptr, channel);\n}\n\n/**\n * Threshold an image using a standard thresholding algorithm.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `threshold` - The amount the image should be thresholded by from 0 to 255.\n * # Example\n *\n * ```no_run\n * // For example, to threshold an image of type `PhotonImage`:\n * use photon_rs::monochrome::threshold;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * threshold(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} threshold\n */\nexport function threshold(img, threshold) {\n    _assertClass(img, PhotonImage);\n    wasm.threshold(img.__wbg_ptr, threshold);\n}\n\n/**\n * Applies gamma correction to an image.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `red` - Gamma value for red channel.\n * * `green` - Gamma value for green channel.\n * * `blue` - Gamma value for blue channel.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a gamma corrected image:\n * use photon_rs::colour_spaces::gamma_correction;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * gamma_correction(&mut img, 2.2, 2.2, 2.2);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} red\n * @param {number} green\n * @param {number} blue\n */\nexport function gamma_correction(photon_image, red, green, blue) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.gamma_correction(photon_image.__wbg_ptr, red, green, blue);\n}\n\n/**\n * Image manipulation effects in the HSLuv colour space\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsluv(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsluv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsluv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation effects in the LCh colour space\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lch(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function lch(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.lch(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation effects in the HSL colour space.\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsl(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsl(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsl(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Image manipulation in the HSV colour space.\n *\n * Effects include:\n * * **saturate** - Saturation increase.\n * * **desaturate** - Desaturate the image.\n * * **shift_hue** - Hue rotation by a specified number of degrees.\n * * **darken** - Decrease the brightness.\n * * **lighten** - Increase the brightness.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `mode` - The effect desired to be applied. Choose from: `saturate`, `desaturate`, `shift_hue`, `darken`, `lighten`\n * * `amt` - A float value from 0 to 1 which represents the amount the effect should be increased by.\n *\n * # Example\n * ```no_run\n * // For example to increase the saturation by 10%:\n * use photon_rs::colour_spaces::hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hsv(&mut img, \"saturate\", 0.1_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {string} mode\n * @param {number} amt\n */\nexport function hsv(photon_image, mode, amt) {\n    _assertClass(photon_image, PhotonImage);\n    const ptr0 = passStringToWasm0(mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.hsv(photon_image.__wbg_ptr, ptr0, len0, amt);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSL colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsl(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsl(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsl(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSV colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSV colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsv(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsv(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the LCh colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_lch(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_lch(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_lch(img.__wbg_ptr, degrees);\n}\n\n/**\n * Shift hue by a specified number of degrees in the HSLuv colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `mode` - A float value from 0 to 1 which is the amount to shift the hue by, or hue rotate by.\n *\n * # Example\n * ```no_run\n * // For example to hue rotate/shift the hue by 120 degrees in the HSL colour space:\n * use photon_rs::colour_spaces::hue_rotate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * hue_rotate_hsluv(&mut img, 120_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} degrees\n */\nexport function hue_rotate_hsluv(img, degrees) {\n    _assertClass(img, PhotonImage);\n    wasm.hue_rotate_hsluv(img.__wbg_ptr, degrees);\n}\n\n/**\n * Increase the image's saturation by converting each pixel's colour to the HSL colour space\n * and increasing the colour's saturation.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::saturate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the LCh colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 40% in the Lch colour space:\n * use photon_rs::colour_spaces::saturate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_lch(&mut img, 0.4_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the HSLuv colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 40% in the HSLuv colour space:\n * use photon_rs::colour_spaces::saturate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsluv(&mut img, 0.4_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Increase the image's saturation in the HSV colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level by which to increase the saturation by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Increasing saturation by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to increase saturation by 30% in the HSV colour space:\n * use photon_rs::colour_spaces::saturate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * saturate_hsv(&mut img, 0.3_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function saturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.saturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::lighten_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::lighten_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSL colour space.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::lighten_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Lighten an image by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to lighten the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Lightening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to lighten an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::lighten_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lighten_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function lighten_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.lighten_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::darken_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::darken_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image by a specified amount in the HSL colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSL colour space:\n * use photon_rs::colour_spaces::darken_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Darken the image's colours by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to darken the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Darkening by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to darken an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::darken_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * darken_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function darken_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.darken_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSV colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the HSV colour space:\n * use photon_rs::colour_spaces::desaturate_hsv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsv(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSL colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::desaturate_hsl;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsl(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsl(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsl(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the LCh colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the LCh colour space:\n * use photon_rs::colour_spaces::desaturate_lch;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_lch(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_lch(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_lch(img.__wbg_ptr, level);\n}\n\n/**\n * Desaturate the image by a specified amount in the HSLuv colour space.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `level` - Float value from 0 to 1 representing the level to which to desaturate the image by.\n * The `level` must be from 0 to 1 in floating-point, `f32` format.\n * Desaturating by 80% would be represented by a `level` of 0.8\n *\n * # Example\n * ```no_run\n * // For example to desaturate an image by 10% in the HSLuv colour space:\n * use photon_rs::colour_spaces::desaturate_hsluv;\n * use photon_rs::native::open_image;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * desaturate_hsluv(&mut img, 0.1_f32);\n * ```\n * @param {PhotonImage} img\n * @param {number} level\n */\nexport function desaturate_hsluv(img, level) {\n    _assertClass(img, PhotonImage);\n    wasm.desaturate_hsluv(img.__wbg_ptr, level);\n}\n\n/**\n * Mix image with a single color, supporting passing `opacity`.\n * The algorithm comes from Jimp. See `function mix` and `function colorFn` at following link:\n * https://github.com/oliver-moran/jimp/blob/29679faa597228ff2f20d34c5758e4d2257065a3/packages/plugin-color/src/index.js\n * Specifically, result_value = (mix_color_value - origin_value) * opacity + origin_value =\n * mix_color_value * opacity + (1 - opacity) * origin_value for each\n * of RGB channel.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `mix_color` - the color to be mixed in, as an RGB value.\n * * `opacity` - the opacity of color when mixed to image. Float value from 0 to 1.\n * # Example\n *\n * ```no_run\n * // For example, to mix an image with rgb (50, 255, 254) and opacity 0.4:\n * use photon_rs::Rgb;\n * use photon_rs::colour_spaces::mix_with_colour;\n * use photon_rs::native::open_image;\n *\n * let mix_colour = Rgb::new(50_u8, 255_u8, 254_u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * mix_with_colour(&mut img, mix_colour, 0.4_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {Rgb} mix_colour\n * @param {number} opacity\n */\nexport function mix_with_colour(photon_image, mix_colour, opacity) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(mix_colour, Rgb);\n    var ptr0 = mix_colour.__destroy_into_raw();\n    wasm.mix_with_colour(photon_image.__wbg_ptr, ptr0, opacity);\n}\n\n/**\n * Noise reduction.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to noise reduct an image:\n * use photon_rs::conv::noise_reduction;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * noise_reduction(&mut img);\n * ```\n * Adds a constant to a select R, G, or B channel's value.\n * @param {PhotonImage} photon_image\n */\nexport function noise_reduction(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.noise_reduction(photon_image.__wbg_ptr);\n}\n\n/**\n * Sharpen an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to sharpen an image:\n * use photon_rs::conv::sharpen;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sharpen(&mut img);\n * ```\n * Adds a constant to a select R, G, or B channel's value.\n * @param {PhotonImage} photon_image\n */\nexport function sharpen(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sharpen(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply edge detection to an image, to create a dark version with its edges highlighted.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to increase the Red channel for all pixels by 10:\n * use photon_rs::conv::edge_detection;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * edge_detection(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function edge_detection(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_detection(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply an identity kernel convolution to an image.\n *\n * # Arguments\n * * `img` -A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply an identity kernel convolution:\n * use photon_rs::conv::identity;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * identity(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function identity(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.identity(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a box blur effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a box blur effect:\n * use photon_rs::conv::box_blur;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * box_blur(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function box_blur(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.box_blur(photon_image.__wbg_ptr);\n}\n\n/**\n * Gaussian blur in linear time.\n *\n * Reference: http://blog.ivank.net/fastest-gaussian-blur.html\n *\n * # Arguments\n * * `photon_image` - A PhotonImage\n * * `radius` - blur radius\n * # Example\n *\n * ```no_run\n * use photon_rs::conv::gaussian_blur;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * gaussian_blur(&mut img, 3_i32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} radius\n */\nexport function gaussian_blur(photon_image, radius) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.gaussian_blur(photon_image.__wbg_ptr, radius);\n}\n\n/**\n * Detect horizontal lines in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the horizontal lines in an image:\n * use photon_rs::conv::detect_horizontal_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_horizontal_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_horizontal_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_horizontal_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect vertical lines in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the vertical lines in an image:\n * use photon_rs::conv::detect_vertical_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_vertical_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_vertical_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_vertical_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect lines at a forty five degree angle in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the lines at a forty five degree angle in an image:\n * use photon_rs::conv::detect_45_deg_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_45_deg_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_45_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_45_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Detect lines at a 135 degree angle in an image, and highlight these only.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to display the lines at a 135 degree angle in an image:\n * use photon_rs::conv::detect_135_deg_lines;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * detect_135_deg_lines(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function detect_135_deg_lines(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.detect_135_deg_lines(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a standard laplace convolution.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a laplace effect:\n * use photon_rs::conv::laplace;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * laplace(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function laplace(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.laplace(photon_image.__wbg_ptr);\n}\n\n/**\n * Preset edge effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply this effect:\n * use photon_rs::conv::edge_one;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * edge_one(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function edge_one(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.edge_one(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply an emboss effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply an emboss effect:\n * use photon_rs::conv::emboss;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * emboss(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function emboss(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.emboss(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a horizontal Sobel filter to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a horizontal Sobel filter:\n * use photon_rs::conv::sobel_horizontal;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_horizontal(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a horizontal Prewitt convolution to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a horizontal Prewitt convolution effect:\n * use photon_rs::conv::prewitt_horizontal;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * prewitt_horizontal(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function prewitt_horizontal(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.prewitt_horizontal(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a vertical Sobel filter to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a vertical Sobel filter:\n * use photon_rs::conv::sobel_vertical;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_vertical(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_vertical(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_vertical(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a global Sobel filter to an image\n *\n * Each pixel is calculated as the magnitude of the horizontal and vertical components of the Sobel filter,\n * ie if X is the horizontal sobel and Y is the vertical, for each pixel, we calculate sqrt(X^2 + Y^2)\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a global Sobel filter:\n * use photon_rs::conv::sobel_global;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * sobel_global(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function sobel_global(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.sobel_global(photon_image.__wbg_ptr);\n}\n\n/**\n * Add randomized noise to an image.\n * This function adds a Gaussian Noise Sample to each pixel through incrementing each channel by a randomized offset.\n * This randomized offset is generated by creating a randomized thread pool.\n * **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n * a workaround using js_sys::Math::random works now.\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example:\n * use photon_rs::native::open_image;\n * use photon_rs::noise::add_noise_rand;\n * use photon_rs::PhotonImage;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * add_noise_rand(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function add_noise_rand(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.add_noise_rand(photon_image.__wbg_ptr);\n}\n\n/**\n * Add pink-tinted noise to an image.\n *\n * **[WASM SUPPORT IS AVAILABLE]**: Randomized thread pools cannot be created with WASM, but\n * a workaround using js_sys::Math::random works now.\n * # Arguments\n * * `name` - A PhotonImage that contains a view into the image.\n *\n * # Example\n *\n * ```no_run\n * // For example, to add pink-tinted noise to an image:\n * use photon_rs::native::open_image;\n * use photon_rs::noise::pink_noise;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pink_noise(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function pink_noise(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.pink_noise(photon_image.__wbg_ptr);\n}\n\n/**\n * Add a watermark to an image.\n *\n * # Arguments\n * * `img` - A DynamicImage that contains a view into the image.\n * * `watermark` - The watermark to be placed onto the `img` image.\n * * `x` - The x coordinate where the watermark's top corner should be positioned.\n * * `y` - The y coordinate where the watermark's top corner should be positioned.\n * # Example\n *\n * ```no_run\n * // For example, to add a watermark to an image at x: 30, y: 40:\n * use photon_rs::multiple::watermark;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let water_mark = open_image(\"watermark.jpg\").expect(\"File should open\");\n * watermark(&mut img, &water_mark, 30_i64, 40_i64);\n * ```\n * @param {PhotonImage} img\n * @param {PhotonImage} watermark\n * @param {bigint} x\n * @param {bigint} y\n */\nexport function watermark(img, watermark, x, y) {\n    _assertClass(img, PhotonImage);\n    _assertClass(watermark, PhotonImage);\n    wasm.watermark(img.__wbg_ptr, watermark.__wbg_ptr, x, y);\n}\n\n/**\n * Blend two images together.\n *\n * The `blend_mode` (3rd param) determines which blending mode to use; change this for varying effects.\n * The blend modes available include: `overlay`, `over`, `atop`, `xor`, `plus`, `multiply`, `burn`,\n * `difference`, `soft_light`, `screen`, `hard_light`, `dodge`, `exclusion`, `lighten`, `darken` (more to come)\n * NOTE: The first image must be smaller than the second image passed as params.\n * If the first image were larger than the second, then there would be overflowing pixels which would have no corresponding pixels\n * in the second image.\n * # Arguments\n * * `img` - A DynamicImage that contains a view into the image.\n * * `img2` - The 2nd DynamicImage to be blended with the first.\n * * `blend_mode` - The blending mode to use. See above for complete list of blend modes available.\n * # Example\n *\n * ```no_run\n * // For example, to blend two images with the `multiply` blend mode:\n * use photon_rs::multiple::blend;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let img2 = open_image(\"img2.jpg\").expect(\"File should open\");\n * blend(&mut img, &img2, \"multiply\");\n * ```\n * @param {PhotonImage} photon_image\n * @param {PhotonImage} photon_image2\n * @param {string} blend_mode\n */\nexport function blend(photon_image, photon_image2, blend_mode) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(photon_image2, PhotonImage);\n    const ptr0 = passStringToWasm0(blend_mode, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.blend(photon_image.__wbg_ptr, photon_image2.__wbg_ptr, ptr0, len0);\n}\n\n/**\n * @param {number} width\n * @param {number} height\n * @returns {PhotonImage}\n */\nexport function create_gradient(width, height) {\n    const ret = wasm.create_gradient(width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply a gradient to an image.\n * @param {PhotonImage} image\n */\nexport function apply_gradient(image) {\n    _assertClass(image, PhotonImage);\n    wasm.apply_gradient(image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Blue channel.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::neue;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * neue(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function neue(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.neue(photon_image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Red and Green channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::lix;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lix(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function lix(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.lix(photon_image.__wbg_ptr);\n}\n\n/**\n * Solarization on the Red and Blue channels.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::ryo;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * ryo(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function ryo(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.ryo(photon_image.__wbg_ptr);\n}\n\n/**\n * Apply a filter to an image. Over 20 filters are available.\n * The filters are as follows:\n * * **oceanic**: Add an aquamarine-tinted hue to an image.\n * * **islands**: Aquamarine tint.\n * * **marine**: Add a green/blue mixed hue to an image.\n * * **seagreen**: Dark green hue, with tones of blue.\n * * **flagblue**: Royal blue tint\n * * **liquid**: Blue-inspired tint.\n * * **diamante**: Custom filter with a blue/turquoise tint.\n * * **radio**: Fallout-style radio effect.\n * * **twenties**: Slight-blue tinted historical effect.\n * * **rosetint**: Rose-tinted filter.\n * * **mauve**: Purple-infused filter.\n * * **bluechrome**: Blue monochrome effect.\n * * **vintage**: Vintage filter with a red tint.\n * * **perfume**: Increase the blue channel, with moderate increases in the Red and Green channels.\n * * **serenity**: Custom filter with an increase in the Blue channel's values.\n * # Arguments\n * * `img` - A PhotonImage.\n * * `filter_name` - The filter's name. Choose from the selection above, eg: \"oceanic\"\n * # Example\n *\n * ```no_run\n * // For example, to add a filter called \"vintage\" to an image:\n * use photon_rs::filters::filter;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * filter(&mut img, \"vintage\");\n * ```\n * @param {PhotonImage} img\n * @param {string} filter_name\n */\nexport function filter(img, filter_name) {\n    _assertClass(img, PhotonImage);\n    const ptr0 = passStringToWasm0(filter_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.filter(img.__wbg_ptr, ptr0, len0);\n}\n\n/**\n * Apply a lofi effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::lofi;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * lofi(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function lofi(img) {\n    _assertClass(img, PhotonImage);\n    wasm.lofi(img.__wbg_ptr);\n}\n\n/**\n * Apply a rose tint to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::pastel_pink;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pastel_pink(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function pastel_pink(img) {\n    _assertClass(img, PhotonImage);\n    wasm.pastel_pink(img.__wbg_ptr);\n}\n\n/**\n * Apply a vintage, golden hue to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::golden;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * golden(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function golden(img) {\n    _assertClass(img, PhotonImage);\n    wasm.golden(img.__wbg_ptr);\n}\n\n/**\n * Increased contrast filter effect.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::cali;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * cali(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function cali(img) {\n    _assertClass(img, PhotonImage);\n    wasm.cali(img.__wbg_ptr);\n}\n\n/**\n * Greyscale effect with increased contrast.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::dramatic;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * dramatic(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function dramatic(img) {\n    _assertClass(img, PhotonImage);\n    wasm.dramatic(img.__wbg_ptr);\n}\n\n/**\n * Monochrome tint effect with increased contrast\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `rgb_color` - RGB color\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::monochrome_tint;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgb_color = Rgb::new(12, 12, 10);\n * monochrome_tint(&mut img, rgb_color);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} rgb_color\n */\nexport function monochrome_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    _assertClass(rgb_color, Rgb);\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.monochrome_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n * Duotone effect with blue and purple tones.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_violette;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_violette(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_violette(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_violette(img.__wbg_ptr);\n}\n\n/**\n * Duotone effect with purple tones.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_horizon;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_horizon(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_horizon(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_horizon(img.__wbg_ptr);\n}\n\n/**\n * A duotone filter with a user-specified color and a gray color\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `rgb_color` - RGB color\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_tint;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgb_color = Rgb::new(12, 12, 10);\n * duotone_tint(&mut img, rgb_color);\n * ```\n * @param {PhotonImage} img\n * @param {Rgb} rgb_color\n */\nexport function duotone_tint(img, rgb_color) {\n    _assertClass(img, PhotonImage);\n    _assertClass(rgb_color, Rgb);\n    var ptr0 = rgb_color.__destroy_into_raw();\n    wasm.duotone_tint(img.__wbg_ptr, ptr0);\n}\n\n/**\n * Duotone effect with a lilac hue\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_lilac;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_lilac(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_lilac(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_lilac(img.__wbg_ptr);\n}\n\n/**\n * A duotone ochre tint effect\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::duotone_ochre;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * duotone_ochre(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function duotone_ochre(img) {\n    _assertClass(img, PhotonImage);\n    wasm.duotone_ochre(img.__wbg_ptr);\n}\n\n/**\n * Apply a red hue, with increased contrast and brightness.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::firenze;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * firenze(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function firenze(img) {\n    _assertClass(img, PhotonImage);\n    wasm.firenze(img.__wbg_ptr);\n}\n\n/**\n * Apply a greyscale effect with increased contrast.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * # Example\n *\n * ```no_run\n * use photon_rs::filters::obsidian;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * obsidian(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function obsidian(img) {\n    _assertClass(img, PhotonImage);\n    wasm.obsidian(img.__wbg_ptr);\n}\n\n/**\n * Crop an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to crop an image at (0, 0) to (500, 800)\n * use photon_rs::native::{open_image};\n * use photon_rs::transform::crop;\n * use photon_rs::PhotonImage;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let cropped_img: PhotonImage = crop(&img, 0_u32, 0_u32, 500_u32, 800_u32);\n * // Write the contents of this image in JPG format.\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @returns {PhotonImage}\n */\nexport function crop(photon_image, x1, y1, x2, y2) {\n    _assertClass(photon_image, PhotonImage);\n    const ret = wasm.crop(photon_image.__wbg_ptr, x1, y1, x2, y2);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * @param {HTMLCanvasElement} source_canvas\n * @param {number} width\n * @param {number} height\n * @param {number} left\n * @param {number} top\n * @returns {HTMLCanvasElement}\n */\nexport function crop_img_browser(source_canvas, width, height, left, top) {\n    const ret = wasm.crop_img_browser(source_canvas, width, height, left, top);\n    return ret;\n}\n\n/**\n * Flip an image horizontally.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to flip an image horizontally:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::fliph;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * fliph(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function fliph(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.fliph(photon_image.__wbg_ptr);\n}\n\n/**\n * Flip an image vertically.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n *\n * # Example\n *\n * ```no_run\n * // For example, to flip an image vertically:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::flipv;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * flipv(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function flipv(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.flipv(photon_image.__wbg_ptr);\n}\n\n/**\n * Resize an image on the web.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n * * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n * @param {PhotonImage} photon_img\n * @param {number} width\n * @param {number} height\n * @param {SamplingFilter} sampling_filter\n * @returns {HTMLCanvasElement}\n */\nexport function resize_img_browser(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.resize_img_browser(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return ret;\n}\n\n/**\n * Resize an image.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n * * `sampling_filter` - Nearest = 1, Triangle = 2, CatmullRom = 3, Gaussian = 4, Lanczos3 = 5\n * @param {PhotonImage} photon_img\n * @param {number} width\n * @param {number} height\n * @param {SamplingFilter} sampling_filter\n * @returns {PhotonImage}\n */\nexport function resize(photon_img, width, height, sampling_filter) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.resize(photon_img.__wbg_ptr, width, height, sampling_filter);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Resize image using seam carver.\n * Resize only if new dimensions are smaller, than original image.\n * # NOTE: This is still experimental feature, and pretty slow.\n *\n * # Arguments\n * * `img` - A PhotonImage.\n * * `width` - New width.\n * * `height` - New height.\n *\n * # Example\n *\n * ```no_run\n * // For example, resize image using seam carver:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::seam_carve;\n * use photon_rs::PhotonImage;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let result: PhotonImage = seam_carve(&img, 100_u32, 100_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} width\n * @param {number} height\n * @returns {PhotonImage}\n */\nexport function seam_carve(img, width, height) {\n    _assertClass(img, PhotonImage);\n    const ret = wasm.seam_carve(img.__wbg_ptr, width, height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Shear the image along the X axis.\n * A sheared PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `shear` - Amount to shear.\n *\n * # Example\n *\n * ```no_run\n * // For example, to shear an image by 0.5:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::shearx;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let sheared_img = shearx(&img, 0.5);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} shear\n * @returns {PhotonImage}\n */\nexport function shearx(photon_img, shear) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.shearx(photon_img.__wbg_ptr, shear);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Shear the image along the Y axis.\n * A sheared PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `shear` - Amount to shear.\n *\n * # Example\n *\n * ```no_run\n * // For example, to shear an image by 0.5:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::sheary;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let sheared_img = sheary(&img, 0.5);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} shear\n * @returns {PhotonImage}\n */\nexport function sheary(photon_img, shear) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.sheary(photon_img.__wbg_ptr, shear);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply uniform padding around the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels around a PhotonImage:\n * use photon_rs::transform::padding_uniform;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_uniform(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_uniform(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_uniform(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the left side of a PhotonImage:\n * use photon_rs::transform::padding_left;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_left(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_left(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_left(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the right side of a PhotonImage:\n * use photon_rs::transform::padding_right;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_right(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_right(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_right(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the top of a PhotonImage:\n * use photon_rs::transform::padding_top;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_top(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_top(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_top(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Apply padding on the left side of the PhotonImage\n * A padded PhotonImage is returned.\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `padding` - The amount of padding to be applied to the PhotonImage.\n * * `padding_rgba` - Tuple containing the RGBA code for padding color.\n *\n * # Example\n *\n * ```no_run\n * // For example, to apply a padding of 10 pixels on the bottom of a PhotonImage:\n * use photon_rs::transform::padding_bottom;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgba;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rgba = Rgba::new(200_u8, 100_u8, 150_u8, 255_u8);\n * padding_bottom(&img, 10_u32, rgba);\n * ```\n * @param {PhotonImage} img\n * @param {number} padding\n * @param {Rgba} padding_rgba\n * @returns {PhotonImage}\n */\nexport function padding_bottom(img, padding, padding_rgba) {\n    _assertClass(img, PhotonImage);\n    _assertClass(padding_rgba, Rgba);\n    var ptr0 = padding_rgba.__destroy_into_raw();\n    const ret = wasm.padding_bottom(img.__wbg_ptr, padding, ptr0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Rotate the PhotonImage on an arbitrary angle\n * A rotated PhotonImage is returned.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `angle` - Rotation angle in degrees.\n *\n * # Example\n *\n * ```no_run\n * // For example, to rotate a PhotonImage by 30 degrees:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::rotate;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rotated_img = rotate(&img, 30.0);\n * ```\n * @param {PhotonImage} photon_img\n * @param {number} angle\n * @returns {PhotonImage}\n */\nexport function rotate(photon_img, angle) {\n    _assertClass(photon_img, PhotonImage);\n    const ret = wasm.rotate(photon_img.__wbg_ptr, angle);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Resample the PhotonImage.\n *\n * # Arguments\n * * `img` - A PhotonImage. See the PhotonImage struct for details.\n * * `dst_width` - Target width.\n * * `dst_height` - Target height.\n *\n * # Example\n *\n * ```no_run\n * // For example, to resample a PhotonImage to 1920x1080 size:\n * use photon_rs::native::open_image;\n * use photon_rs::transform::resample;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let rotated_img = resample(&img, 1920, 1080);\n * ```\n * @param {PhotonImage} img\n * @param {number} dst_width\n * @param {number} dst_height\n * @returns {PhotonImage}\n */\nexport function resample(img, dst_width, dst_height) {\n    _assertClass(img, PhotonImage);\n    const ret = wasm.resample(img.__wbg_ptr, dst_width, dst_height);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Adds an offset to the image by a certain number of pixels.\n *\n * This creates an RGB shift effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `channel_index`: The index of the channel to increment. 0 for red, 1 for green and 2 for blue.\n * * `offset` - The offset is added to the pixels in the image.\n * # Example\n *\n * ```no_run\n * // For example, to offset pixels by 30 pixels on the red channel:\n * use photon_rs::effects::offset;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset(&mut img, 0_usize, 30_u32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} channel_index\n * @param {number} offset\n */\nexport function offset(photon_image, channel_index, offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.offset(photon_image.__wbg_ptr, channel_index, offset);\n}\n\n/**\n * Adds an offset to the red channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset you want to move the red channel by.\n * # Example\n *\n * ```no_run\n * // For example, to add an offset to the red channel by 30 pixels.\n * use photon_rs::effects::offset_red;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_red(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_red(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_red(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds an offset to the green channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset you want to move the green channel by.\n * # Example\n *\n * ```no_run\n * // For example, to add an offset to the green channel by 30 pixels.\n * use photon_rs::effects::offset_green;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_green(&mut img, 30_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_green(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_green(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds an offset to the blue channel by a certain number of pixels.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset_amt` - The offset you want to move the blue channel by.\n * # Example\n * // For example, to add an offset to the green channel by 40 pixels.\n *\n * ```no_run\n * use photon_rs::effects::offset_blue;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * offset_blue(&mut img, 40_u32);\n * ```\n * @param {PhotonImage} img\n * @param {number} offset_amt\n */\nexport function offset_blue(img, offset_amt) {\n    _assertClass(img, PhotonImage);\n    wasm.offset_blue(img.__wbg_ptr, offset_amt);\n}\n\n/**\n * Adds multiple offsets to the image by a certain number of pixels (on two channels).\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `offset` - The offset is added to the pixels in the image.\n * # Example\n *\n * ```no_run\n * // For example, to add a 30-pixel offset to both the red and blue channels:\n * use photon_rs::effects::multiple_offsets;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * multiple_offsets(&mut img, 30_u32, 0_usize, 2_usize);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} offset\n * @param {number} channel_index\n * @param {number} channel_index2\n */\nexport function multiple_offsets(photon_image, offset, channel_index, channel_index2) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.multiple_offsets(photon_image.__wbg_ptr, offset, channel_index, channel_index2);\n}\n\n/**\n * Halftoning effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example:\n * use photon_rs::effects::halftone;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * halftone(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function halftone(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.halftone(photon_image.__wbg_ptr);\n}\n\n/**\n * Reduces an image to the primary colours.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to add a primary colour effect to an image of type `DynamicImage`:\n * use photon_rs::effects::primary;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * primary(&mut img);\n * ```\n * @param {PhotonImage} img\n */\nexport function primary(img) {\n    _assertClass(img, PhotonImage);\n    wasm.primary(img.__wbg_ptr);\n}\n\n/**\n * Colorizes the green channels of the image.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to colorize an image of type `PhotonImage`:\n * use photon_rs::effects::colorize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * colorize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function colorize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.colorize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies a solarizing effect to an image.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to colorize an image of type `PhotonImage`:\n * use photon_rs::effects::solarize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * solarize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function solarize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.solarize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies a solarizing effect to an image and returns the resulting PhotonImage.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to solarize \"retimg\" an image of type `PhotonImage`:\n * use photon_rs::effects::solarize_retimg;\n * use photon_rs::native::open_image;\n * use photon_rs::PhotonImage;\n *\n * let img = open_image(\"img.jpg\").expect(\"File should open\");\n * let result: PhotonImage = solarize_retimg(&img);\n * ```\n * @param {PhotonImage} photon_image\n * @returns {PhotonImage}\n */\nexport function solarize_retimg(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    const ret = wasm.solarize_retimg(photon_image.__wbg_ptr);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Adjust the brightness of an image by a factor.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to add or subtract to the brightness. To increase\n * the brightness, pass a positive number (up to 255). To decrease the brightness,\n * pass a negative number instead.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::adjust_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * adjust_brightness(&mut img, 10_i16);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function adjust_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.adjust_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Increase the brightness of an image by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to add to the brightness.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::inc_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * inc_brightness(&mut img, 10_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function inc_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.inc_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Decrease the brightness of an image by a constant.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `brightness` - A u8 to subtract from the brightness. It should be a positive number,\n * and this value will then be subtracted from the brightness.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::dec_brightness;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * dec_brightness(&mut img, 10_u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} brightness\n */\nexport function dec_brightness(photon_image, brightness) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.dec_brightness(photon_image.__wbg_ptr, brightness);\n}\n\n/**\n * Adjust the contrast of an image by a factor.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `contrast` - An f32 factor used to adjust contrast. Between [-255.0, 255.0]. The algorithm will\n * clamp results if passed factor is out of range.\n * # Example\n *\n * ```no_run\n * use photon_rs::effects::adjust_contrast;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * adjust_contrast(&mut img, 30_f32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} contrast\n */\nexport function adjust_contrast(photon_image, contrast) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.adjust_contrast(photon_image.__wbg_ptr, contrast);\n}\n\n/**\n * Tint an image by adding an offset to averaged RGB channel values.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `r_offset` - The amount the R channel should be incremented by.\n * * `g_offset` - The amount the G channel should be incremented by.\n * * `b_offset` - The amount the B channel should be incremented by.\n * # Example\n *\n * ```no_run\n * // For example, to tint an image of type `PhotonImage`:\n * use photon_rs::effects::tint;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * tint(&mut img, 10_u32, 20_u32, 15_u32);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} r_offset\n * @param {number} g_offset\n * @param {number} b_offset\n */\nexport function tint(photon_image, r_offset, g_offset, b_offset) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.tint(photon_image.__wbg_ptr, r_offset, g_offset, b_offset);\n}\n\n/**\n * Horizontal strips. Divide an image into a series of equal-height strips, for an artistic effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The number of strips\n * # Example\n *\n * ```no_run\n * // For example, to draw horizontal strips on a `PhotonImage`:\n * use photon_rs::effects::horizontal_strips;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * horizontal_strips(&mut img, 8u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n */\nexport function horizontal_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.horizontal_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n * Horizontal strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * * `color` - Color of strips.\n * # Example\n *\n * ```no_run\n * // For example, to draw blue horizontal strips on a `PhotonImage`:\n * use photon_rs::effects::color_horizontal_strips;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let color = Rgb::new(255u8, 0u8, 0u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * color_horizontal_strips(&mut img, 8u8, color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n * @param {Rgb} color\n */\nexport function color_horizontal_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color, Rgb);\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_horizontal_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n * Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * # Example\n *\n * ```no_run\n * // For example, to draw vertical strips on a `PhotonImage`:\n * use photon_rs::effects::vertical_strips;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * vertical_strips(&mut img, 8u8);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n */\nexport function vertical_strips(photon_image, num_strips) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.vertical_strips(photon_image.__wbg_ptr, num_strips);\n}\n\n/**\n * Vertical strips. Divide an image into a series of equal-width strips, for an artistic effect. Sepcify a color as well.\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `num_strips` - The numbder of strips\n * * `color` - Color of strips.\n * # Example\n *\n * ```no_run\n * // For example, to draw red vertical strips on a `PhotonImage`:\n * use photon_rs::effects::color_vertical_strips;\n * use photon_rs::native::open_image;\n * use photon_rs::Rgb;\n *\n * let color = Rgb::new(255u8, 0u8, 0u8);\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * color_vertical_strips(&mut img, 8u8, color);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} num_strips\n * @param {Rgb} color\n */\nexport function color_vertical_strips(photon_image, num_strips, color) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color, Rgb);\n    var ptr0 = color.__destroy_into_raw();\n    wasm.color_vertical_strips(photon_image.__wbg_ptr, num_strips, ptr0);\n}\n\n/**\n * Turn an image into an oil painting\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * * `radius` - Radius of each paint particle\n * * `intesnity` - How artsy an Image should be\n * # Example\n *\n * ```no_run\n * // For example, to oil an image of type `PhotonImage`:\n * use photon_rs::effects::oil;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * oil(&mut img, 4i32, 55.0);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} radius\n * @param {number} intensity\n */\nexport function oil(photon_image, radius, intensity) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.oil(photon_image.__wbg_ptr, radius, intensity);\n}\n\n/**\n * Turn an image into an frosted glass see through\n *\n * # Arguments\n * * `img` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into frosted glass see through:\n * use photon_rs::effects::frosted_glass;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * frosted_glass(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function frosted_glass(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.frosted_glass(photon_image.__wbg_ptr);\n}\n\n/**\n * Pixelize an image.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `pixel_size` - Targeted pixel size of generated image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a pixelized image with 50 pixels blocks:\n * use photon_rs::effects::pixelize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * pixelize(&mut img, 50);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} pixel_size\n */\nexport function pixelize(photon_image, pixel_size) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.pixelize(photon_image.__wbg_ptr, pixel_size);\n}\n\n/**\n * Normalizes an image by remapping its range of pixels values. Only RGB\n * channels are processed and each channel is stretched to \\[0, 255\\] range\n * independently. This process is also known as contrast stretching.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a normalized image:\n * use photon_rs::effects::normalize;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * normalize(&mut img);\n * ```\n * @param {PhotonImage} photon_image\n */\nexport function normalize(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.normalize(photon_image.__wbg_ptr);\n}\n\n/**\n * Applies Floyd-Steinberg dithering to an image.\n * Only RGB channels are processed, alpha remains unchanged.\n * # Arguments\n * * `photon_image` - A PhotonImage that contains a view into the image.\n * * `depth` - bits per channel. Clamped between 1 and 8.\n * # Example\n *\n * ```no_run\n * // For example, to turn an image of type `PhotonImage` into a dithered image:\n * use photon_rs::effects::dither;\n * use photon_rs::native::open_image;\n *\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * let depth = 1;\n * dither(&mut img, depth);\n * ```\n * @param {PhotonImage} photon_image\n * @param {number} depth\n */\nexport function dither(photon_image, depth) {\n    _assertClass(photon_image, PhotonImage);\n    wasm.dither(photon_image.__wbg_ptr, depth);\n}\n\n/**\n * @param {PhotonImage} photon_image\n * @param {Rgb} color_a\n * @param {Rgb} color_b\n */\nexport function duotone(photon_image, color_a, color_b) {\n    _assertClass(photon_image, PhotonImage);\n    _assertClass(color_a, Rgb);\n    var ptr0 = color_a.__destroy_into_raw();\n    _assertClass(color_b, Rgb);\n    var ptr1 = color_b.__destroy_into_raw();\n    wasm.duotone(photon_image.__wbg_ptr, ptr0, ptr1);\n}\n\n/**\n * Add bordered-text to an image.\n * The only font available as of now is Roboto.\n * Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `text` - Text string to be drawn to the image.\n * * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n * * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n * * `font_size` - Font size in pixels of the text to be drawn.\n *\n * # Example\n *\n * ```no_run\n * // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n * use photon_rs::native::open_image;\n * use photon_rs::text::draw_text_with_border;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * draw_text_with_border(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32, 90_f32);\n * ```\n * @param {PhotonImage} photon_img\n * @param {string} text\n * @param {number} x\n * @param {number} y\n * @param {number} font_size\n */\nexport function draw_text_with_border(photon_img, text, x, y, font_size) {\n    _assertClass(photon_img, PhotonImage);\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.draw_text_with_border(photon_img.__wbg_ptr, ptr0, len0, x, y, font_size);\n}\n\n/**\n * Add text to an image.\n * The only font available as of now is Roboto.\n * Note: A graphic design/text-drawing library is currently being developed, so stay tuned.\n *\n * # Arguments\n * * `photon_image` - A PhotonImage.\n * * `text` - Text string to be drawn to the image.\n * * `x` - x-coordinate of where first letter's 1st pixel should be drawn.\n * * `y` - y-coordinate of where first letter's 1st pixel should be drawn.\n * * `font_size` - Font size in pixels of the text to be drawn.\n *\n * # Example\n *\n * ```no_run\n * // For example to draw the string \"Welcome to Photon!\" at 10, 10:\n * use photon_rs::native::open_image;\n * use photon_rs::text::draw_text;\n *\n * // Open the image. A PhotonImage is returned.\n * let mut img = open_image(\"img.jpg\").expect(\"File should open\");\n * draw_text(&mut img, \"Welcome to Photon!\", 10_i32, 10_i32, 90_f32);\n * ```\n * @param {PhotonImage} photon_img\n * @param {string} text\n * @param {number} x\n * @param {number} y\n * @param {number} font_size\n */\nexport function draw_text(photon_img, text, x, y, font_size) {\n    _assertClass(photon_img, PhotonImage);\n    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.draw_text(photon_img.__wbg_ptr, ptr0, len0, x, y, font_size);\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8ArrayMemory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction takeFromExternrefTable0(idx) {\n    const value = wasm.__wbindgen_export_2.get(idx);\n    wasm.__externref_table_dealloc(idx);\n    return value;\n}\n/**\n *! [temp] Check if WASM is supported.\n */\nexport function run() {\n    const ret = wasm.run();\n    if (ret[1]) {\n        throw takeFromExternrefTable0(ret[0]);\n    }\n}\n\n/**\n * Get the ImageData from a 2D canvas context\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @returns {ImageData}\n */\nexport function get_image_data(canvas, ctx) {\n    const ret = wasm.get_image_data(canvas, ctx);\n    return ret;\n}\n\n/**\n * Place a PhotonImage onto a 2D canvas.\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @param {PhotonImage} new_image\n */\nexport function putImageData(canvas, ctx, new_image) {\n    _assertClass(new_image, PhotonImage);\n    var ptr0 = new_image.__destroy_into_raw();\n    wasm.putImageData(canvas, ctx, ptr0);\n}\n\n/**\n * Convert a HTML5 Canvas Element to a PhotonImage.\n *\n * This converts the ImageData found in the canvas context to a PhotonImage,\n * which can then have effects or filters applied to it.\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} ctx\n * @returns {PhotonImage}\n */\nexport function open_image(canvas, ctx) {\n    const ret = wasm.open_image(canvas, ctx);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Convert ImageData to a raw pixel vec of u8s.\n * @param {ImageData} imgdata\n * @returns {Uint8Array}\n */\nexport function to_raw_pixels(imgdata) {\n    const ret = wasm.to_raw_pixels(imgdata);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n}\n\n/**\n * Convert a base64 string to a PhotonImage.\n * @param {string} base64\n * @returns {PhotonImage}\n */\nexport function base64_to_image(base64) {\n    const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.base64_to_image(ptr0, len0);\n    return PhotonImage.__wrap(ret);\n}\n\n/**\n * Convert a base64 string to a Vec of u8s.\n * @param {string} base64\n * @returns {Uint8Array}\n */\nexport function base64_to_vec(base64) {\n    const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len0 = WASM_VECTOR_LEN;\n    const ret = wasm.base64_to_vec(ptr0, len0);\n    var v2 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v2;\n}\n\n/**\n * Convert a PhotonImage to JS-compatible ImageData.\n * @param {PhotonImage} photon_image\n * @returns {ImageData}\n */\nexport function to_image_data(photon_image) {\n    _assertClass(photon_image, PhotonImage);\n    var ptr0 = photon_image.__destroy_into_raw();\n    const ret = wasm.to_image_data(ptr0);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nfunction addToExternrefTable0(obj) {\n    const idx = wasm.__externref_table_alloc();\n    wasm.__wbindgen_export_2.set(idx, obj);\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        const idx = addToExternrefTable0(e);\n        wasm.__wbindgen_exn_store(idx);\n    }\n}\n\nlet cachedUint8ClampedArrayMemory0 = null;\n\nfunction getUint8ClampedArrayMemory0() {\n    if (cachedUint8ClampedArrayMemory0 === null || cachedUint8ClampedArrayMemory0.byteLength === 0) {\n        cachedUint8ClampedArrayMemory0 = new Uint8ClampedArray(wasm.memory.buffer);\n    }\n    return cachedUint8ClampedArrayMemory0;\n}\n\nfunction getClampedArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8ClampedArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nexport const SamplingFilter = Object.freeze({ Nearest:1,\"1\":\"Nearest\",Triangle:2,\"2\":\"Triangle\",CatmullRom:3,\"3\":\"CatmullRom\",Gaussian:4,\"4\":\"Gaussian\",Lanczos3:5,\"5\":\"Lanczos3\", });\n\nconst PhotonImageFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_photonimage_free(ptr >>> 0, 1));\n/**\n * Provides the image's height, width, and contains the image's raw pixels.\n * For use when communicating between JS and WASM, and also natively.\n */\nexport class PhotonImage {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PhotonImage.prototype);\n        obj.__wbg_ptr = ptr;\n        PhotonImageFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        PhotonImageFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_photonimage_free(ptr, 0);\n    }\n    /**\n     * Create a new PhotonImage from a Vec of u8s, which represent raw pixels.\n     * @param {Uint8Array} raw_pixels\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(raw_pixels, width, height) {\n        const ptr0 = passArray8ToWasm0(raw_pixels, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new(ptr0, len0, width, height);\n        this.__wbg_ptr = ret >>> 0;\n        PhotonImageFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Create a new PhotonImage from a base64 string.\n     * @param {string} base64\n     * @returns {PhotonImage}\n     */\n    static new_from_base64(base64) {\n        const ptr0 = passStringToWasm0(base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.base64_to_image(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a byteslice.\n     * @param {Uint8Array} vec\n     * @returns {PhotonImage}\n     */\n    static new_from_byteslice(vec) {\n        const ptr0 = passArray8ToWasm0(vec, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.photonimage_new_from_byteslice(ptr0, len0);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a Blob/File.\n     * @param {Blob} blob\n     * @returns {PhotonImage}\n     */\n    static new_from_blob(blob) {\n        const ret = wasm.photonimage_new_from_blob(blob);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Create a new PhotonImage from a HTMLImageElement\n     * @param {HTMLImageElement} image\n     * @returns {PhotonImage}\n     */\n    static new_from_image(image) {\n        const ret = wasm.photonimage_new_from_image(image);\n        return PhotonImage.__wrap(ret);\n    }\n    /**\n     * Get the width of the PhotonImage.\n     * @returns {number}\n     */\n    get_width() {\n        const ret = wasm.photonimage_get_width(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Get the PhotonImage's pixels as a Vec of u8s.\n     * @returns {Uint8Array}\n     */\n    get_raw_pixels() {\n        const ret = wasm.photonimage_get_raw_pixels(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Get the height of the PhotonImage.\n     * @returns {number}\n     */\n    get_height() {\n        const ret = wasm.photonimage_get_height(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Convert the PhotonImage to base64.\n     * @returns {string}\n     */\n    get_base64() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const ret = wasm.photonimage_get_base64(this.__wbg_ptr);\n            deferred1_0 = ret[0];\n            deferred1_1 = ret[1];\n            return getStringFromWasm0(ret[0], ret[1]);\n        } finally {\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns PNG.\n     * @returns {Uint8Array}\n     */\n    get_bytes() {\n        const ret = wasm.photonimage_get_bytes(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns a JPEG.\n     * @param {number} quality\n     * @returns {Uint8Array}\n     */\n    get_bytes_jpeg(quality) {\n        const ret = wasm.photonimage_get_bytes_jpeg(this.__wbg_ptr, quality);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage to raw bytes. Returns a WEBP.\n     * @returns {Uint8Array}\n     */\n    get_bytes_webp() {\n        const ret = wasm.photonimage_get_bytes_webp(this.__wbg_ptr);\n        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n        return v1;\n    }\n    /**\n     * Convert the PhotonImage's raw pixels to JS-compatible ImageData.\n     * @returns {ImageData}\n     */\n    get_image_data() {\n        const ret = wasm.photonimage_get_image_data(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Convert ImageData to raw pixels, and update the PhotonImage's raw pixels to this.\n     * @param {ImageData} img_data\n     */\n    set_imgdata(img_data) {\n        wasm.photonimage_set_imgdata(this.__wbg_ptr, img_data);\n    }\n    /**\n     * Calculates estimated filesize and returns number of bytes\n     * @returns {bigint}\n     */\n    get_estimated_filesize() {\n        const ret = wasm.photonimage_get_estimated_filesize(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n}\n\nconst RgbFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rgb_free(ptr >>> 0, 1));\n/**\n * RGB color type.\n */\nexport class Rgb {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RgbFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgb_free(ptr, 0);\n    }\n    /**\n     * Create a new RGB struct.\n     * @param {number} r\n     * @param {number} g\n     * @param {number} b\n     */\n    constructor(r, g, b) {\n        const ret = wasm.rgb_new(r, g, b);\n        this.__wbg_ptr = ret >>> 0;\n        RgbFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Set the Red value.\n     * @param {number} r\n     */\n    set_red(r) {\n        wasm.rgb_set_red(this.__wbg_ptr, r);\n    }\n    /**\n     * Get the Green value.\n     * @param {number} g\n     */\n    set_green(g) {\n        wasm.rgb_set_green(this.__wbg_ptr, g);\n    }\n    /**\n     * Set the Blue value.\n     * @param {number} b\n     */\n    set_blue(b) {\n        wasm.rgb_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n     * Get the Red value.\n     * @returns {number}\n     */\n    get_red() {\n        const ret = wasm.rgb_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Green value.\n     * @returns {number}\n     */\n    get_green() {\n        const ret = wasm.rgb_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Blue value.\n     * @returns {number}\n     */\n    get_blue() {\n        const ret = wasm.rgb_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RgbaFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rgba_free(ptr >>> 0, 1));\n/**\n * RGBA color type.\n */\nexport class Rgba {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RgbaFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rgba_free(ptr, 0);\n    }\n    /**\n     * Create a new RGBA struct.\n     * @param {number} r\n     * @param {number} g\n     * @param {number} b\n     * @param {number} a\n     */\n    constructor(r, g, b, a) {\n        const ret = wasm.rgba_new(r, g, b, a);\n        this.__wbg_ptr = ret >>> 0;\n        RgbaFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Set the Red value.\n     * @param {number} r\n     */\n    set_red(r) {\n        wasm.rgb_set_red(this.__wbg_ptr, r);\n    }\n    /**\n     * Get the Green value.\n     * @param {number} g\n     */\n    set_green(g) {\n        wasm.rgb_set_green(this.__wbg_ptr, g);\n    }\n    /**\n     * Set the Blue value.\n     * @param {number} b\n     */\n    set_blue(b) {\n        wasm.rgb_set_blue(this.__wbg_ptr, b);\n    }\n    /**\n     * Set the alpha value.\n     * @param {number} a\n     */\n    set_alpha(a) {\n        wasm.rgba_set_alpha(this.__wbg_ptr, a);\n    }\n    /**\n     * Get the Red value.\n     * @returns {number}\n     */\n    get_red() {\n        const ret = wasm.rgb_get_red(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Green value.\n     * @returns {number}\n     */\n    get_green() {\n        const ret = wasm.rgb_get_green(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the Blue value.\n     * @returns {number}\n     */\n    get_blue() {\n        const ret = wasm.rgb_get_blue(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Get the alpha value for this color.\n     * @returns {number}\n     */\n    get_alpha() {\n        const ret = wasm.rgba_get_alpha(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return ret;\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_instanceof_Window_c4b70662a0d2c5ec = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof Window;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_document_e5c1786dea6542e4 = function(arg0) {\n        const ret = arg0.document;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_body_e70ae6abd01ae584 = function(arg0) {\n        const ret = arg0.body;\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    };\n    imports.wbg.__wbg_createElement_5d4c76f218b78145 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = arg0.createElement(getStringFromWasm0(arg1, arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_width_4c6f0048d64cf86b = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbg_height_21f0d3fd8f753394 = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_width_79e0847ed5883b03 = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbg_height_e4e4e4779f8feac0 = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_data_fda507064d127f5b = function(arg0, arg1) {\n        const ret = arg1.data;\n        const ptr1 = passArray8ToWasm0(ret, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbg_newwithu8clampedarrayandsh_1fddccb3a94a5e05 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = new ImageData(getClampedArrayU8FromWasm0(arg0, arg1), arg2 >>> 0, arg3 >>> 0);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_CanvasRenderingContext2d_3abbe7ec7af32cae = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof CanvasRenderingContext2D;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_drawImage_fede06db74e39a60 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        arg0.drawImage(arg1, arg2, arg3);\n    }, arguments) };\n    imports.wbg.__wbg_drawImage_f395c8e43c79a909 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {\n        arg0.drawImage(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);\n    }, arguments) };\n    imports.wbg.__wbg_getImageData_5e1c242046e6b59e = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        const ret = arg0.getImageData(arg1, arg2, arg3, arg4);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_putImageData_a8b3e177ee06d521 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        arg0.putImageData(arg1, arg2, arg3);\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_HtmlCanvasElement_25d964a0dde6717e = function(arg0) {\n        let result;\n        try {\n            result = arg0 instanceof HTMLCanvasElement;\n        } catch (_) {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_width_dc225e55343b745e = function(arg0) {\n        const ret = arg0.width;\n        return ret;\n    };\n    imports.wbg.__wbg_setwidth_488780db69b08846 = function(arg0, arg1) {\n        arg0.width = arg1 >>> 0;\n    };\n    imports.wbg.__wbg_height_3a8bec2f3fe71b26 = function(arg0) {\n        const ret = arg0.height;\n        return ret;\n    };\n    imports.wbg.__wbg_setheight_1761808c18403921 = function(arg0, arg1) {\n        arg0.height = arg1 >>> 0;\n    };\n    imports.wbg.__wbg_getContext_fc99dbd3a9a7e318 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = arg0.getContext(getStringFromWasm0(arg1, arg2));\n        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n    }, arguments) };\n    imports.wbg.__wbg_settextContent_f82a86a8df347e1c = function(arg0, arg1, arg2) {\n        arg0.textContent = arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2);\n    };\n    imports.wbg.__wbg_appendChild_fa3b00dade9fc4cf = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.appendChild(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_e643855c6572a4a8 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return ret;\n    };\n    imports.wbg.__wbg_call_f96b398515635514 = function() { return handleError(function (arg0, arg1) {\n        const ret = arg0.call(arg1);\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_self_b9aad7f1c618bfaf = function() { return handleError(function () {\n        const ret = self.self;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_window_55e469842c98b086 = function() { return handleError(function () {\n        const ret = window.window;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_d0957e302752547e = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_global_ae2f87312b8987fb = function() { return handleError(function () {\n        const ret = global.global;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = arg0 === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_buffer_fcbfb6d88b2732e9 = function(arg0) {\n        const ret = arg0.buffer;\n        return ret;\n    };\n    imports.wbg.__wbg_new_bc5d9aad3f9ac80e = function(arg0) {\n        const ret = new Uint8Array(arg0);\n        return ret;\n    };\n    imports.wbg.__wbg_set_4b3aa8445ac1e91c = function(arg0, arg1, arg2) {\n        arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_d9c4ded7e708c6a1 = function(arg0) {\n        const ret = arg0.length;\n        return ret;\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(arg1);\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_2;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n    cachedUint8ClampedArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('photon_rs_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n"],
  "mappings": "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",
  "names": ["ptr", "offset", "threshold", "watermark", "offset"]
}
